---
title: C26418 | Dokumentace Microsoftu
ms.date: 11/15/2017
ms.prod: visual-studio-dev15
ms.topic: conceptual
f1_keywords:
- C26418
helpviewer_keywords:
- C26418
ms.assetid: d2c84a40-8a5d-4018-92c2-6498cdd9b541
author: mikeblome
ms.author: mblome
manager: douge
ms.workload:
- multiple
ms.openlocfilehash: 7b8eaf90bb704c0f73ec6df46ac3af10c512c69c
ms.sourcegitcommit: 37fb7075b0a65d2add3b137a5230767aa3266c74
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 01/02/2019
ms.locfileid: "53821910"
---
# <a name="c26418-novalueorconstrefsharedptr"></a>C26418 NO_VALUE_OR_CONST_REF_SHARED_PTR
"Parametr sdíleného ukazatele není zkopírovaný ani přesunutý. Použijte T * nebo T & místo. "

**C++ Core Guidelines**: R.36: Využijte const shared_ptr<widget>& parametr vyjádřit, že ji může uchovávat počet odkazů na objekt

Pokud parametr sdíleného ukazatele je předaný hodnotou nebo odkaz na objekt konstanty se očekává, že funkce bude převzít kontrolu nad životní cyklus její cílové objektů bez ovlivnění volajícího. Kód by měl kopírovat nebo přesunout na jiný objekt sdílený ukazatel sdílený parametr ukazatele nebo předat dál jiným kódem vyvoláním funkce, které přijímají sdílené odkazy. Pokud to není tento případ, pak obyčejný ukazatel nebo odkaz může být vhodná.

## <a name="remarks"></a>Poznámky
-  Tato kontrola rozpozná std::shared_pointer a uživatelem definované typy, které budou pravděpodobně se chovat jako sdílené odkazy. Pro uživatelem definované sdílené odkazy se neočekávají jsou následující vlastnosti:
-  přetížené přistoupit přes ukazatel nebo operátory (veřejné a neodstraněných); přístup člena
-  kopírovací konstuktor ani operátor copy assignment (veřejné a neodstraněných);
-  veřejným destruktorem, což je odstranit ani nastavit na výchozí hodnotu. Prázdné destruktory jsou stále počítá jako uživatelsky definovanou.

## <a name="example"></a>Příklad
rozhraní zbytečných komplikací

```cpp
template<class T>
std::string to_string(const std::shared_ptr<T> &e) // C26418, also C26415 SMART_PTR_NOT_NEEDED
{
    return !e ? null_string : e->to_string();
}
```

## <a name="example"></a>Příklad
komplikace zbytečné rozhraní – zjednodušená

```cpp
template<class T>
std::string to_string(const T *e)
{
    return !e ? null_string : e->to_string();
}
```

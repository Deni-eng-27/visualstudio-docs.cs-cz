---
title: C26400
ms.date: 08/02/2017
ms.topic: conceptual
f1_keywords:
- C26400
helpviewer_keywords:
- C26400
ms.assetid: b27e1c6d-8b52-40b3-9760-b93afef19c7a
author: mikeblome
ms.author: mblome
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: ea1e4a708765a173231689cd9c2037a4a20158af
ms.sourcegitcommit: 535ef05b1e553f0fc66082cd2e0998817eb2a56a
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 10/07/2019
ms.locfileid: "72016615"
---
# <a name="c26400-no_raw_pointer_assignment"></a>C26400 NO_RAW_POINTER_ASSIGNMENT

Tato kontrolu pomáhá vymáhat @no__t 0rule I. 11: Nikdy nepřeveďte vlastnictví pomocí nezpracovaného ukazatele (T @ no__t-0) *, což je podmnožina pravidla *R. 3: Neupravený ukazatel (a T @ no__t-0) není vlastníkem.* Konkrétně upozorňuje na jakékoli volání operátoru `new`, který uloží svůj výsledek do proměnné typu nezpracovaného ukazatele. Také upozorňuje na volání funkcí, které vrací `gsl::owner<T>`, pokud jsou jejich výsledky přiřazeny nezpracovaným ukazatelům. Tady je, že byste měli jasně uvést vlastnictví paměťových prostředků. Další informace najdete v [ C++ základních pokynech](http://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#r-resource-management).

Nejjednodušší způsob, jak tento problém vyřešit, je použití deklarace `auto`, pokud je prostředek přiřazen ihned v deklaraci proměnné. Pokud to není možné, doporučujeme, abyste použili typ `gsl::owner<T>`. Deklarace `auto` inicializované s operátorem `new` jsou "vlastníci", protože předpokládáme, že výsledek jakékoli alokace je implicitně ukazatel na vlastníka. Tento předpoklad přeneseme do proměnné `auto` a považuje se za `owner<T>`.

Pokud tato kontrolu označí volání funkce, která vrací `owner<T>`, může to být označení legitimní chyby v kódu. V podstatě odkazuje na místo, kde kód nevrací explicitní pojem vlastnictví (a možná samotný prostředek).

## <a name="remarks"></a>Poznámky

Toto pravidlo aktuálně kontroluje pouze místní proměnné. Pokud je přidělení přiřazeno formálnímu parametru, globální proměnné, členu třídy a tak dále, není označen příznakem. Příslušné pokrytí takových scénářů je součástí budoucí práce.

## <a name="example-1-simple-allocation"></a>Příklad 1: Jednoduché přidělení

```cpp
char *buffer = nullptr;
if (useCache)
    buffer = GetCache();
else
    buffer = new char[bufferSize];  // C26400
```

## <a name="example-2-simple-allocation-fixed-with-gslownert"></a>Příklad 2: Jednoduché přidělení (pevné s GSL:: Owner @ no__t-0T >)

```cpp
gsl::owner<char*> buffer = nullptr;
if (useCache)
    buffer = GetCache();
else
    buffer = new char[bufferSize];  // OK

Example 3: Simple allocation (fixed with auto)
auto buffer = useCache ? GetCache() : new char[bufferSize]; // OK
```

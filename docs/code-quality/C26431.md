---
title: C26431
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26431
helpviewer_keywords:
- C26431
ms.assetid: 40be6032-c8de-49ab-8e43-e8eedc0ca0ba
author: mikeblome
ms.author: mblome
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 029b3b076688f6aab4a70a9077b01ddd2ea35586
ms.sourcegitcommit: e98db44f3a33529b0ba188d24390efd09e548191
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 09/25/2019
ms.locfileid: "71253347"
---
# <a name="c26431-dont_test_notnull"></a>C26431 DONT_TEST_NOTNULL

"Typ výrazu je již GSL:: Not_Null. Netestujte ho na hodnotu null. "

**C++ Základní pokyny**: F. 23: Použijte Not_Null\<T > k označení, že "null" není platná hodnota.

Typ značky GSL:: Not_Null z pokynů knihovny support Library slouží k jasnému označení hodnot, které nikdy nepoužívají ukazatele s hodnotou null. Dojde k závažné chybě, pokud takový předpoklad není v době běhu uchováván. Takže není nutné kontrolovat hodnotu null, pokud je výraz vyhodnocen jako výsledek typu GSL:: Not_Null.

## <a name="remarks"></a>Poznámky

- Vzhledem k tomu, že GSL:: Not_Null sám je Obálková třída tenkého ukazatele, pravidlo ve skutečnosti sleduje dočasné proměnné, které obsahují výsledky volání přetíženého operátoru převodu (který vrací objekt ukazatele, který obsahuje). Tato logika toto pravidlo platí pro výrazy, které zahrnují proměnné a nakonec mají výsledek typu GSL:: Not_Null. Ale aktuálně přeskočí výrazy, které obsahují volání funkcí vracející GSL:: Not_Null.
  - Aktuální heuristická kontrola hodnoty null detekuje následující kontexty:
  - výraz symbolu v podmínce větve, například if (p) {...};
  - nebitové logické operace;
  - operace porovnání, kde jeden operand je konstantní výraz, který je vyhodnocen jako nula.

## <a name="example"></a>Příklad

nepotřebné kontroly s hodnotou null odhalují logiku s otázkou

```cpp
class type {
public:
    template<class T> bool is() const;
    template<class T> gsl::not_null<const T*> as() const;
    //...
};

class alias_type : public type {
public:
    gsl::not_null<const type*> get_underlying_type() const;
    gsl::not_null<const type*> get_root_type() const
    {
        const auto ut = get_underlying_type();
        if (ut)                                     // C26431
        {
            const auto uat = ut->as<alias_type>();
            if (uat)                                // C26431, also incorrect use of API!
                return uat->get_root_type();

            return ut;
        }

        return this;                                // Alias to nothing? Actually, dead code!
    }
    //...
};
```

zbytečné kontroly s hodnotou null odhalují problematickou logiku – reworking

```cpp
    //...
    gsl::not_null<const type*> get_root_type() const
    {
        const auto ut = get_underlying_type();
        if (ut->is<alias_type>())
            return ut->as<alias_type>()->get_root_type();

        return ut;
    }
    //...
```

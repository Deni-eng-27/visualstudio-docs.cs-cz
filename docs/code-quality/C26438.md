---
title: C26438
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26438
helpviewer_keywords:
- C26438
ms.assetid: c7b3f59c-fb2f-4816-bda4-0fad23c80d83
author: corob-msft
ms.author: corob
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: 07bbc72a15e47ac4dd48b7cc32e3c866f77228c3
ms.sourcegitcommit: 68f893f6e472df46f323db34a13a7034dccad25a
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 02/15/2020
ms.locfileid: "77271136"
---
# <a name="c26438-no_goto"></a>C26438 NO_GOTO

"Vyhněte se příkazu goto".

Základní pokyny: ES. 76: Vyhněte se příkazu goto **C++**

Použití příkazu goto je široce potvrzené jako nebezpečné a v praxi náchylné k chybám. Je přijatelné pouze v generovaném kódu (např. v analyzátoru vygenerovaném z gramatiky). Díky moderním C++ funkcím a nástrojům, které poskytuje pokyny pro podporu knihovny, by se mělo snadno vyhnout příkazu goto.

## <a name="remarks"></a>Poznámky

- Toto pravidlo se upozorní na libovolný výskyt příkazu goto, i když k němu dojde v nedoručeném kódu, s výjimkou kódu šablony, který se nikdy nepoužívá, a proto je kompilátorem ignorován.
  - Pokud narazíte na makro obsahující příkaz goto, můžou být upozornění na vysokou úroveň. Aktuální mechanismus generování sestav by odkazoval na všechny instance, kde se toto makro rozšíří. Tuto opravu lze ale obvykle provést na jednom místě změnou makra nebo zabráněním použití IT a využitím více udržovatelných mechanismů.

## <a name="example"></a>Příklad

goto Cleanup v makru

```cpp
#define ENSURE(E, L) if (!(E)) goto L;

void poll(connection &c)
{
    ENSURE(c.open(), end);                  // C26438

    while (c.wait())
    {
        connection::header h{};
        connection::signature s{};
        ENSURE(c.read_header(h), end);      // C26438
        ENSURE(c.read_signature(s), end);   // C26438
        // ...
    }

end:
    c.close();
}
```

goto Cleanup v makru – nahrazené GSL:: finally

```cpp
void poll(connection &c)
{
    auto end = gsl::finally([&c] { c.close(); });

    if (!c.open())
        return;

    while (c.wait())
    {
        connection::header h{};
        connection::signature s{};
        if(!c.read_header(h))
            return;
       if(!c.read_signature(s))
            return;
        // ...
    }
}
```

---
title: 'CA2000: Uvolňujte objekty před ztrátou oboru'
ms.date: 05/14/2019
ms.topic: reference
f1_keywords:
- CA2000
- Dispose objects before losing scope
- DisposeObjectsBeforeLosingScope
helpviewer_keywords:
- CA2000
- DisposeObjectsBeforeLosingScope
ms.assetid: 0c3d7d8d-b94d-46e8-aa4c-38df632c1463
author: mikejo5000
ms.author: mikejo
manager: jillfra
dev_langs:
- CSharp
- VB
ms.workload:
- multiple
ms.openlocfilehash: bd835ab0163b9abe2b3b94950e15b92f6f84f2f1
ms.sourcegitcommit: 6cfffa72af599a9d667249caaaa411bb28ea69fd
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 09/02/2020
ms.locfileid: "88709659"
---
# <a name="ca2000-dispose-objects-before-losing-scope"></a>CA2000: Uvolňujte objekty před ztrátou oboru

|Položka|Hodnota|
|-|-|
|CheckId|CA2000|
|Kategorie|Microsoft.Reliability|
|Zásadní změna|Nenarušující|

## <a name="cause"></a>Příčina

<xref:System.IDisposable>Je vytvořen místní objekt typu, ale objekt není uvolněn předtím, než jsou všechny odkazy na objekt mimo rozsah.

Ve výchozím nastavení toto pravidlo analyzuje celý základ kódu, ale je možné ho [nakonfigurovat](#configurability).

## <a name="rule-description"></a>Popis pravidla

Pokud není uvolnitelný objekt explicitně odstraněn před tím, než jsou všechny odkazy mimo rozsah, bude objekt odstraněn v době, kdy bude systémem uvolňování paměti spuštěna finalizační metoda objektu. Vzhledem k tomu, že může dojít k mimořádné události, která zabrání spuštění finalizační metody objektu, měl by namísto toho být objekt explicitně odstraněn.

### <a name="special-cases"></a>Zvláštní případy

Pravidlo CA2000 se neaktivuje pro lokální objekty následujících typů, i když objekt není vyřazený:

- <xref:System.IO.Stream?displayProperty=nameWithType>
- <xref:System.IO.StringReader?displayProperty=nameWithType>
- <xref:System.IO.TextReader?displayProperty=nameWithType>
- <xref:System.IO.TextWriter?displayProperty=nameWithType>
- <xref:System.Resources.IResourceReader?displayProperty=nameWithType>

Předání objektu jednoho z těchto typů konstruktoru a jeho přiřazení k poli indikuje *přenos vlastnictví* do nově vytvořeného typu. To znamená, že nově konstruovaný typ je nyní zodpovědný za likvidaci objektu. Pokud váš kód předává objektu jeden z těchto typů konstruktoru, nedojde k žádnému porušení pravidla CA2000, i když objekt není uvolněn předtím, než jsou všechny odkazy na něj mimo obor.

## <a name="how-to-fix-violations"></a>Jak opravit porušení

Chcete-li vyřešit porušení tohoto pravidla, musíte zavolat na objekt metodu <xref:System.IDisposable.Dispose%2A> před tím, než jsou všechny odkazy na něj mimo rozsah.

[ `using` ](/dotnet/csharp/language-reference/keywords/using-statement) [`Using`](/dotnet/visual-basic/language-reference/statements/using-statement) K zabalení objektů, které implementují, můžete použít příkaz (v Visual Basic) <xref:System.IDisposable> . Objekty, které jsou zabaleny tímto způsobem, jsou automaticky odstraněny na konci `using` bloku. Následující situace by však neměly být zpracovány `using` příkazem:

- Chcete-li vrátit objekt na jedno použití, musí být objekt vytvořen v `try/finally` bloku mimo `using` blok.

- Neinicializujte členy objektu na jedno použití v konstruktoru `using` příkazu.

- Pokud jsou konstruktory, které jsou chráněny pouze jednou obslužnou rutinou výjimky, vnořené v [části získání `using` příkazu](/dotnet/csharp/language-reference/language-specification/statements#the-using-statement), selhání vnějšího konstruktoru může způsobit, že objekt vytvořený vnořeným konstruktorem nebude nikdy zavřen. V následujícím příkladu může selhání v <xref:System.IO.StreamReader> konstruktoru způsobit, že se <xref:System.IO.FileStream> objekt nikdy neuzavře. CA2000 v tomto případě označí porušení pravidla.

   ```csharp
   using (StreamReader sr = new StreamReader(new FileStream("C:\myfile.txt", FileMode.Create)))
   { ... }
   ```

- Dynamické objekty by měly použít stínový objekt k implementaci vzoru Dispose <xref:System.IDisposable> objektů.

## <a name="when-to-suppress-warnings"></a>Kdy potlačit upozornění

Potlačit upozornění z tohoto pravidla, pokud:

- Pro váš objekt jste volali metodu, která volá `Dispose` , například <xref:System.IO.Stream.Close%2A>
- Metoda, která vyvolala varování, vrátí <xref:System.IDisposable> objekt, který zabalí váš objekt.
- Metoda přidělování nemá vlastnictví Dispose; To znamená, že odpovědnost za likvidaci objektu je převedena na jiný objekt nebo obálku, která je vytvořena v metodě a vrácena volajícímu.

## <a name="configurability"></a>Konfigurovatelnost

Toto pravidlo má následující konfigurovatelné možnosti.

### <a name="excluded-symbol-names"></a>Vyloučené názvy symbolů

Můžete nakonfigurovat, které části vašeho základu kódu budou vyloučeny z analýzy. Například chcete-li určit, že pravidlo by nemělo běžet pro žádný kód v rámci typů s názvem `MyType` , přidejte do souboru. editorconfig v projektu následující dvojici klíč-hodnota:

```ini
dotnet_code_quality.CA2000.excluded_symbol_names = MyType
```

Povolené formáty názvů symbolů v hodnotě možnosti (oddělené |):
- Pouze název symbolu (včetně všech symbolů s názvem, bez ohledu na obsahující typ nebo obor názvů)
- Plně kvalifikované názvy ve [formátu ID dokumentace k](https://github.com/dotnet/csharplang/blob/master/spec/documentation-comments.md#id-string-format)symbolu. Každý název symbolu vyžaduje předponu typu symbolu, jako je například "M:" prefix pro metody, předpona "T:" pro typy, předpona "N:" pro obory názvů atd.
- `.ctor` pro konstruktory a `.cctor` pro statické konstruktory

Příklady:

| Hodnota možnosti | Shrnutí |
| --- | --- |
|`dotnet_code_quality.CA2000.excluded_symbol_names = MyType` | Odpovídá všem symbolům s názvem ' MyType ' v kompilaci
|`dotnet_code_quality.CA2000.excluded_symbol_names = MyType1|MyType2` | Odpovídá všem symbolům s názvem ' MyType1 ' nebo ' MyType2 ' v kompilaci
|`dotnet_code_quality.CA2000.excluded_symbol_names = M:NS.MyType.MyMethod(ParamType)` | Odpovídá konkrétní metodě ' MyMethod ' s daným plně kvalifikovaným podpisem
|`dotnet_code_quality.CA2000.excluded_symbol_names = M:NS1.MyType1.MyMethod1(ParamType)|M:NS2.MyType2.MyMethod2(ParamType)` | Odpovídá specifickým metodám ' MyMethod1 ' a ' MyMethod2 ' s odpovídajícím plně kvalifikovaným podpisem

Všechny tyto možnosti můžete nakonfigurovat jenom pro toto pravidlo, pro všechna pravidla nebo pro všechna pravidla v této kategorii (návrh). Další informace najdete v tématu [Konfigurace analyzátorů kvality kódu .NET](configure-fxcop-analyzers.md).

## <a name="related-rules"></a>Související pravidla

- [CA2213: Uvolnitelná pole by měla být uvolněna](../code-quality/ca2213.md)
- [CA2202: Neuvolňujte objekty několikrát](../code-quality/ca2202.md)

## <a name="example"></a>Příklad

Pokud implementujete metodu, která vrací objekt na jedno použití, použijte blok try/finally bez bloku catch k zajištění toho, aby byl objekt uvolněn. Pomocí bloku try/finally lze povolit vyvolání výjimek v místě selhání a zajistit, aby byl objekt uvolněn.

V metodě OpenPort1 se volání za účelem otevření objektu ISerializable SerialPort nebo volání metody SomeMethod nemusí zdařit. V této implementaci je vyvoláno upozornění CA2000.

V metodě OpenPort2 jsou deklarovány dva objekty SerialPort a jsou nastaveny na hodnotu null:

- `tempPort`, který slouží k otestování úspěšné operace metody.

- `port`, který se používá pro návratovou hodnotu metody.

Objekt `tempPort` je vytvořen a otevřen v rámci bloku `try` a jakákoli jiná požadovaná činnost je vykonána v rámci stejného bloku `try`. Na konci bloku `try` je otevřený port přiřazen objektu `port`, který bude vrácen, a objekt `tempPort` je nastaven na hodnotu `null`.

Blok `finally` ověřuje hodnotu `tempPort`. Pokud hodnota není null, operace se v rámci metody nezdařila a blok `tempPort` je uzavřen, aby bylo možné zajistit uvolnění jakýchkoli prostředků. Vrácený objekt portu bude obsahovat otevřený objekt SerialPort, pokud byly operace metody úspěšné, nebo bude mít hodnotu null, pokud se operace nezdaří.

```csharp
public SerialPort OpenPort1(string portName)
{
   SerialPort port = new SerialPort(portName);
   port.Open();  //CA2000 fires because this might throw
   SomeMethod(); //Other method operations can fail
   return port;
}

public SerialPort OpenPort2(string portName)
{
   SerialPort tempPort = null;
   SerialPort port = null;
   try
   {
      tempPort = new SerialPort(portName);
      tempPort.Open();
      SomeMethod();
      //Add any other methods above this line
      port = tempPort;
      tempPort = null;

   }
   finally
   {
      if (tempPort != null)
      {
         tempPort.Close();
      }
   }
   return port;
}
```

```vb
Public Function OpenPort1(ByVal PortName As String) As SerialPort

   Dim port As New SerialPort(PortName)
   port.Open()    'CA2000 fires because this might throw
   SomeMethod()   'Other method operations can fail
   Return port

End Function

Public Function OpenPort2(ByVal PortName As String) As SerialPort

   Dim tempPort As SerialPort = Nothing
   Dim port As SerialPort = Nothing

   Try
      tempPort = New SerialPort(PortName)
      tempPort.Open()
      SomeMethod()
      'Add any other methods above this line
      port = tempPort
      tempPort = Nothing

   Finally
      If Not tempPort Is Nothing Then
         tempPort.Close()
      End If

   End Try

   Return port

End Function
```

## <a name="example"></a>Příklad

Ve výchozím nastavení má kompilátor Visual Basic všechny aritmetické operátory kontroluje přetečení. Proto může jakákoli aritmetická operace jazyka Visual Basic vyvolat výjimku <xref:System.OverflowException>. To může vést k neočekávaným případům porušování pravidel, jako je například CA2000. Například následující funkce CreateReader1 ohlásí porušení pravidla CA2000, protože kompilátor jazyka Visual Basic generuje dodatečnou instrukci kontroly přetečení, jež může vyvolat výjimku, která může způsobit, že StreamReader nebude odstraněn.

Chcete-li tento problém vyřešit, můžete zakázat generování kontrol přetečení kompilátorem jazyka Visual Basic v rámci projektu nebo upravit kód tak, jak je tomu v následující funkci CreateReader2.

Chcete-li zakázat generování kontrol přetečení, klikněte pravým tlačítkem myši na název projektu v Průzkumník řešení a potom klikněte na příkaz **vlastnosti**. Klikněte na **kompilovat**, klikněte na **Pokročilé možnosti kompilace**a potom zaškrtněte políčko **Odebrat kontroly přetečení celých čísel**.

[!code-vb[FxCop.Reliability.CA2000.DisposeObjectsBeforeLosingScope#1](../code-quality/codesnippet/VisualBasic/ca2000-dispose-objects-before-losing-scope-vboverflow_1.vb)]

## <a name="see-also"></a>Viz také

- <xref:System.IDisposable>
- [Vzor pro metodu Dispose](/dotnet/standard/design-guidelines/dispose-pattern)

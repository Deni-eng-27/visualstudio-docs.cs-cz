---
title: 'CA2000: Uvolňujte objekty před ztrátou oboru'
ms.date: 05/14/2019
ms.topic: reference
f1_keywords:
- CA2000
- Dispose objects before losing scope
- DisposeObjectsBeforeLosingScope
helpviewer_keywords:
- CA2000
- DisposeObjectsBeforeLosingScope
ms.assetid: 0c3d7d8d-b94d-46e8-aa4c-38df632c1463
author: mikejo5000
ms.author: mikejo
manager: jillfra
dev_langs:
- CSharp
- VB
ms.workload:
- multiple
ms.openlocfilehash: 387f1c3d763b15cdbf9ff3cc21375958dc213058
ms.sourcegitcommit: 4bcd6abb89feff1cf8251e3ded73fdc30b67e347
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 04/17/2020
ms.locfileid: "81615578"
---
# <a name="ca2000-dispose-objects-before-losing-scope"></a>CA2000: Uvolňujte objekty před ztrátou oboru

|||
|-|-|
|TypeName|DisposeObjectsBeforeLosingScope|
|CheckId|CA2000|
|Kategorie|Microsoft.Reliability|
|Narušující změny|Nenarušující|

## <a name="cause"></a>Příčina

Místní objekt <xref:System.IDisposable> typu je vytvořen, ale objekt není uvolněnpřed všechny odkazy na objekt jsou mimo rozsah.

Ve výchozím nastavení toto pravidlo analyzuje celý základ kódu, ale toto je [konfigurovatelné](#configurability).

## <a name="rule-description"></a>Popis pravidla

Pokud není uvolnitelný objekt explicitně odstraněn před tím, než jsou všechny odkazy mimo rozsah, bude objekt odstraněn v době, kdy bude systémem uvolňování paměti spuštěna finalizační metoda objektu. Vzhledem k tomu, že může dojít k mimořádné události, která zabrání spuštění finalizační metody objektu, měl by namísto toho být objekt explicitně odstraněn.

### <a name="special-cases"></a>Zvláštní případy

Pravidlo CA2000 není požární pro místní objekty následujících typů i v případě, že objekt není uvolněn:

- <xref:System.IO.Stream?displayProperty=nameWithType>
- <xref:System.IO.StringReader?displayProperty=nameWithType>
- <xref:System.IO.TextReader?displayProperty=nameWithType>
- <xref:System.IO.TextWriter?displayProperty=nameWithType>
- <xref:System.Resources.IResourceReader?displayProperty=nameWithType>

Předání objektu jednoho z těchto typů konstruktoru a jeho přiřazení k poli znamená *převod vlastnictví dispose* nově postavenému typu. To znamená, že nově vytvořený typ je nyní zodpovědný za likvidaci objektu. Pokud váš kód předá objekt jednoho z těchto typů konstruktoru, žádné porušení pravidla CA2000 dochází i v případě, že objekt není uvolněna před všechny odkazy na něj jsou mimo rozsah.

## <a name="how-to-fix-violations"></a>Jak opravit porušení

Chcete-li vyřešit porušení tohoto pravidla, musíte zavolat na objekt metodu <xref:System.IDisposable.Dispose%2A> před tím, než jsou všechny odkazy na něj mimo rozsah.

Příkaz [ `using` (v](/dotnet/csharp/language-reference/keywords/using-statement) [`Using`](/dotnet/visual-basic/language-reference/statements/using-statement) jazyce Visual Basic) můžete <xref:System.IDisposable>použít k zalomení objektů, které implementují . Objekty, které jsou zabaleny tímto způsobem jsou `using` automaticky vyřazeny na konci bloku. Následující situace by však neměly nebo `using` nemohou být zpracovány s prohlášením:

- Chcete-li vrátit jednorázový objekt, musí `try/finally` být objekt `using` vytvořen v bloku mimo blok.

- Neinicializovat členy objektu na jedno použití `using` v konstruktoru příkazu.

- Když konstruktory, které jsou chráněny pouze jeden obslužná rutina výjimky jsou vnořeny v [pořizovací části příkazu `using` ](/dotnet/csharp/language-reference/language-specification/statements#the-using-statement), selhání ve vnějším konstruktoru může mít za následek objekt vytvořený vnořený konstruktor nikdy uzavřen. V následujícím příkladu selhání <xref:System.IO.StreamReader> v konstruktoru <xref:System.IO.FileStream> může mít za následek nikdy uzavřen objekt. CA2000 příznaky porušení pravidla v tomto případě.

   ```csharp
   using (StreamReader sr = new StreamReader(new FileStream("C:\myfile.txt", FileMode.Create)))
   { ... }
   ```

- Dynamické objekty by měly používat stínový <xref:System.IDisposable> objekt k implementaci disponujením vzoru objektů.

## <a name="when-to-suppress-warnings"></a>Kdy potlačit varování

Upozornění od tohoto pravidla nepotlačujte, pokud:

- Volali jste metodu objektu, `Dispose`která volá , například<xref:System.IO.Stream.Close%2A>
- Metoda, která vyvolala <xref:System.IDisposable> upozornění vrátí objekt, který obtéká objekt
- Metoda přidělování nemá dispose vlastnictví; To znamená, že odpovědnost za vyřazení objektu je přenesena na jiný objekt nebo obálku, která je vytvořena v metodě a vrácena volajícímu

## <a name="configurability"></a>Konfigurovatelnost

Pokud používáte toto pravidlo z [analyzátorů FxCop](install-fxcop-analyzers.md) (a ne s analýzou starší verze), můžete nakonfigurovat analýzu pro toto pravidlo.

### <a name="excluded-symbol-names"></a>Názvy vyloučených symbolů

Můžete nakonfigurovat, které části základu kódu vyloučit z analýzy. Chcete-li například určit, že pravidlo by nemělo být spuštěno na žádném kódu v rámci typů s názvem `MyType`, přidejte do souboru .editorconfig v projektu následující dvojici klíč-hodnota:

```ini
dotnet_code_quality.CA2000.excluded_symbol_names = MyType
```

Povolené formáty názvů symbolů v hodnotě volby (oddělené |):
  - Pouze název symbolu (obsahuje všechny symboly s názvem, bez ohledu na obsahující typ nebo obor názvů)
  - Plně kvalifikované názvy ve [formátu ID dokumentace symbolu](https://github.com/dotnet/csharplang/blob/master/spec/documentation-comments.md#id-string-format). Každý název symbolu vyžaduje předponu typu symbolu, například předponu "M:" pro metody, předponu "T:" pro typy, předponu "N:" pro obory názvů atd.
  - `.ctor`pro konstruktory `.cctor` a pro statické konstruktory

Příklady:

| Hodnota možnosti | Souhrn |
| --- | --- |
|`dotnet_code_quality.CA2000.excluded_symbol_names = MyType` | Odpovídá všem symbolům s názvem "MyType" v kompilaci.
|`dotnet_code_quality.CA2000.excluded_symbol_names = MyType1|MyType2` | Porovnává všechny symboly s názvem MyType1 nebo MyType2 v kompilaci.
|`dotnet_code_quality.CA2000.excluded_symbol_names = M:NS.MyType.MyMethod(ParamType)` | Odpovídá konkrétní metodě MyMethod s daným plně kvalifikovaným podpisem.
|`dotnet_code_quality.CA2000.excluded_symbol_names = M:NS1.MyType1.MyMethod1(ParamType)|M:NS2.MyType2.MyMethod2(ParamType)` | Odpovídá specifickým metodám MyMethod1 a MyMethod2 s příslušným plně kvalifikovaným podpisem.

Všechny tyto možnosti můžete nakonfigurovat pouze pro toto pravidlo, pro všechna pravidla nebo pro všechna pravidla v této kategorii (Návrh). Další informace naleznete v [tématu Konfigurace analyzátorů FxCop](configure-fxcop-analyzers.md).

## <a name="related-rules"></a>Související pravidla

- [CA2213: Uvolnitelné pole by mělo být uvolněno](../code-quality/ca2213.md)
- [CA2202: Neuvolňujte objekty několikrát](../code-quality/ca2202.md)

## <a name="example"></a>Příklad

Pokud implementujete metodu, která vrací jednorázový objekt, použijte blok try/finally bez bloku catch a ujistěte se, že je objekt uvolněn. Pomocí bloku try/finally lze povolit vyvolání výjimek v místě selhání a zajistit, aby byl objekt uvolněn.

V metodě OpenPort1 se volání za účelem otevření objektu ISerializable SerialPort nebo volání metody SomeMethod nemusí zdařit. V této implementaci je vyvoláno upozornění CA2000.

V metodě OpenPort2 jsou deklarovány dva objekty SerialPort a jsou nastaveny na hodnotu null:

- `tempPort`, který se používá k testování, že operace metody úspěšné.

- `port`, který se používá pro vrácenou hodnotu metody.

Objekt `tempPort` je vytvořen a otevřen v rámci bloku `try` a jakákoli jiná požadovaná činnost je vykonána v rámci stejného bloku `try`. Na konci bloku `try` je otevřený port přiřazen objektu `port`, který bude vrácen, a objekt `tempPort` je nastaven na hodnotu `null`.

Blok `finally` ověřuje hodnotu `tempPort`. Pokud hodnota není null, operace se v rámci metody nezdařila a blok `tempPort` je uzavřen, aby bylo možné zajistit uvolnění jakýchkoli prostředků. Vrácený objekt portu bude obsahovat otevřený objekt SerialPort, pokud byly operace metody úspěšné, nebo bude mít hodnotu null, pokud se operace nezdaří.

```csharp
public SerialPort OpenPort1(string portName)
{
   SerialPort port = new SerialPort(portName);
   port.Open();  //CA2000 fires because this might throw
   SomeMethod(); //Other method operations can fail
   return port;
}

public SerialPort OpenPort2(string portName)
{
   SerialPort tempPort = null;
   SerialPort port = null;
   try
   {
      tempPort = new SerialPort(portName);
      tempPort.Open();
      SomeMethod();
      //Add any other methods above this line
      port = tempPort;
      tempPort = null;

   }
   finally
   {
      if (tempPort != null)
      {
         tempPort.Close();
      }
   }
   return port;
}
```

```vb
Public Function OpenPort1(ByVal PortName As String) As SerialPort

   Dim port As New SerialPort(PortName)
   port.Open()    'CA2000 fires because this might throw
   SomeMethod()   'Other method operations can fail
   Return port

End Function

Public Function OpenPort2(ByVal PortName As String) As SerialPort

   Dim tempPort As SerialPort = Nothing
   Dim port As SerialPort = Nothing

   Try
      tempPort = New SerialPort(PortName)
      tempPort.Open()
      SomeMethod()
      'Add any other methods above this line
      port = tempPort
      tempPort = Nothing

   Finally
      If Not tempPort Is Nothing Then
         tempPort.Close()
      End If

   End Try

   Return port

End Function
```

## <a name="example"></a>Příklad

Ve výchozím nastavení má kompilátor jazyka všechny aritmetické operátory zkontrolovat přetečení. Proto může jakákoli aritmetická operace jazyka Visual Basic vyvolat výjimku <xref:System.OverflowException>. To může vést k neočekávaným případům porušování pravidel, jako je například CA2000. Například následující funkce CreateReader1 ohlásí porušení pravidla CA2000, protože kompilátor jazyka Visual Basic generuje dodatečnou instrukci kontroly přetečení, jež může vyvolat výjimku, která může způsobit, že StreamReader nebude odstraněn.

Chcete-li tento problém vyřešit, můžete zakázat generování kontrol přetečení kompilátorem jazyka Visual Basic v rámci projektu nebo upravit kód tak, jak je tomu v následující funkci CreateReader2.

Chcete-li zakázat vyzařování kontrol přetečení, klepněte pravým tlačítkem myši na název projektu v Průzkumníku řešení a potom klepněte na příkaz **Vlastnosti**. Klepněte na **tlačítko Kompilovat**, klepněte na **položku Upřesnit možnosti kompilace**a zaškrtněte políčko **Odebrat kontroly přetečení celého čísla**.

[!code-vb[FxCop.Reliability.CA2000.DisposeObjectsBeforeLosingScope#1](../code-quality/codesnippet/VisualBasic/ca2000-dispose-objects-before-losing-scope-vboverflow_1.vb)]

## <a name="see-also"></a>Viz také

- <xref:System.IDisposable>
- [Vzor pro metodu Dispose](/dotnet/standard/design-guidelines/dispose-pattern)

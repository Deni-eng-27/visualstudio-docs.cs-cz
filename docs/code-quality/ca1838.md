---
title: 'CA1838: Nepoužívejte parametry StringBuilder pro volání nespravovaného kódu'
ms.date: 08/03/2020
ms.topic: reference
f1_keywords:
- AvoidStringBuilderPInvokeParameters
- CA1838
helpviewer_keywords:
- AvoidStringBuilderPInvokeParameters
- CA1838
author: elinor-fung
ms.author: elfung
manager: jeffschw
ms.workload:
- multiple
ms.openlocfilehash: fc0458d8d493f39f1403cf03a8cf542933c9cd99
ms.sourcegitcommit: 4ae5e9817ad13edd05425febb322b5be6d3c3425
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 09/11/2020
ms.locfileid: "90036129"
---
# <a name="ca1838-avoid-stringbuilder-parameters-for-pinvokes"></a>CA1838: Vyhněte se `StringBuilder` parametrům pro volání nespravovaného volání

|Položka|Hodnota|
|-|-|
|CheckId|CA1838|
|Kategorie|Microsoft. Performance|
|Zásadní změna|Nenarušující|

## <a name="cause"></a>Příčina

[P/Invoke](/dotnet/standard/native-interop/pinvoke) má <xref:System.Text.StringBuilder> parametr.

## <a name="rule-description"></a>Popis pravidla

Zařazování `StringBuilder` vždy vytvoří nativní kopii vyrovnávací paměti a výsledkem je vícenásobné přidělení pro jedno volání volání nespravovaného kódu. Chcete-li zařadit a `StringBuilder` jako parametr P/Invoke, bude modul runtime:
- Přidělit nativní vyrovnávací paměť
- Pokud se jedná o `In` parametr, zkopírujte obsah do `StringBuilder` nativní vyrovnávací paměti.
- Pokud se jedná o `Out` parametr, zkopírujte nativní vyrovnávací paměť do nově přiděleného spravovaného pole.

Ve výchozím nastavení `StringBuilder` jsou `In` a `Out` .

Toto pravidlo je ve výchozím nastavení zakázáno, protože může vyžadovat analýzu velkých a malých písmen, zda je porušení důležité a potenciálně netriviální Refaktoring pro vyřešení porušení. Uživatelé můžou toto pravidlo explicitně povolit konfigurací [závažnosti pravidel analyzátoru](use-roslyn-analyzers.md#configure-severity-levels).

## <a name="how-to-fix-violations"></a>Jak opravit porušení

Obecně platí, že řešení porušení zahrnuje přepracování volání volání nespravovaného systému a jeho volajících k použití vyrovnávací paměti místo `StringBuilder` . Konkrétní by záviset na případech použití pro volání nespravovaného volání.

Tady je příklad pro běžný scénář použití `StringBuilder` jako výstupní vyrovnávací paměť, která se má vyplnit nativní funkcí:

```csharp
// Violation
[DllImport("MyLibrary", CharSet = CharSet.Unicode)]
private static extern void Foo(StringBuilder sb, ref int length);

public void Bar()
{
    int BufferSize = ...
    StringBuilder sb = new StringBuilder(BufferSize);
    int len = sb.Capacity;
    Foo(sb, ref len);
    string result = sb.ToString();
}
```

Pro případy použití, kde je velikost vyrovnávací paměti malá a `unsafe` je přípustný kód, lze [stackalloc](/dotnet/csharp/language-reference/operators/stackalloc) použít k přidělení vyrovnávací paměti v zásobníku:

```csharp
[DllImport("MyLibrary", CharSet = CharSet.Unicode)]
private static extern unsafe void Foo(char* buffer, ref int length);

public void Bar()
{
    int BufferSize = ...
    unsafe
    {
        char* buffer = stackalloc char[BufferSize];
        int len = BufferSize;
        Foo(buffer, ref len);
        string result = new string(buffer);
    }
}
```

Pro větší vyrovnávací paměti lze nové pole přidělit jako vyrovnávací paměť:

```csharp
[DllImport("MyLibrary", CharSet = CharSet.Unicode)]
private static extern void Foo([Out] char[] buffer, ref int length);

public void Bar()
{
    int BufferSize = ...
    char[] buffer = new char[BufferSize];
    int len = buffer.Length;
    Foo(buffer, ref len);
    string result = new string(buffer);
}
```

Pokud je P/Invoke často voláno pro větší vyrovnávací paměti, <xref:System.Buffers.ArrayPool%601> lze použít k zamezení opakovanému přidělení a tlaku paměti, který je součástí těchto:

```csharp
[DllImport("MyLibrary", CharSet = CharSet.Unicode)]
private static extern unsafe void Foo([Out] char[] buffer, ref int length);

public void Bar()
{
    int BufferSize = ...
    char[] buffer = ArrayPool<char>.Shared.Rent(BufferSize);
    try
    {
        int len = buffer.Length;
        Foo(buffer, ref len);
        string result = new string(buffer);
    }
    finally
    {
        ArrayPool<char>.Shared.Return(buffer);
    }
}
```

Pokud velikost vyrovnávací paměti není až do doby běhu známa, může být nutné vytvořit jinou vyrovnávací paměť založenou na velikosti, abyste se vyhnuli přidělování velkých vyrovnávacích pamětí `stackalloc` .

V předchozích příkladech se používají 2 bajty velkých písmen ( `CharSet.Unicode` ). Pokud nativní funkce používá dvoubajtové znaky ( `CharSet.Ansi` ), `byte` lze místo vyrovnávací paměti použít vyrovnávací paměť `char` . Například:

```csharp
[DllImport("MyLibrary", CharSet = CharSet.Ansi)]
private static extern unsafe void Foo(byte* buffer, ref int length);

public void Bar()
{
    int BufferSize = ...
    unsafe
    {
        byte* buffer = stackalloc byte[BufferSize];
        int len = BufferSize;
        Foo(buffer, ref len);
        string result = Marshal.PtrToStringAnsi((IntPtr)buffer);
    }
}
```

Pokud je parametr také použit jako vstup, vyrovnávací paměti musí být naplněny daty řetězce s libovolným znakem null explicitně přidán.

## <a name="when-to-suppress-warnings"></a>Kdy potlačit upozornění

Potlačit porušení tohoto pravidla, pokud nejste v souvislosti s dopadem na výkon zařazování a `StringBuilder` .

## <a name="see-also"></a>Viz také

- [Upozornění výkonu](../code-quality/performance-warnings.md)
- [Nativní osvědčené postupy interoperability](/dotnet/standard/native-interop/best-practices)
- <xref:System.Buffers.ArrayPool%601>
- [stackalloc](/dotnet/csharp/language-reference/operators/stackalloc)
- [Znakových sad](/dotnet/standard/native-interop/charset)

---
title: C26449
ms.date: 03/22/2018
ms.topic: reference
f1_keywords:
- C26449
helpviewer_keywords:
- C26449
author: mikeblome
ms.author: mblome
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: aed9a5e85ce21694446d9f92959669488fb52c53
ms.sourcegitcommit: 535ef05b1e553f0fc66082cd2e0998817eb2a56a
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 10/07/2019
ms.locfileid: "72015491"
---
# <a name="c26449-no_span_from_temporary"></a>C26449 NO_SPAN_FROM_TEMPORARY

`gsl::span` nebo `std::string_view` vytvořené z dočasného typu budou neplatné při zrušení platnosti dočasného údaje.

C++Základní pokyny: [GSL. View: zobrazení](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#gslview-views).

Rozsahy a zobrazení jsou pohodlné a odlehčené typy umožňující odkazování na vyrovnávací paměti. Musí být však pečlivě používány: i když jejich rozhraní vypadá podobně jako standardní kontejnery, jejich chování je větší jako chování ukazatelů a odkazů. Nevlastní data a nesmí být nikdy sestavena z dočasné vyrovnávací paměti. Tato kontroler se zaměřuje na případy, kdy jsou zdrojová data dočasná, zatímco rozsah nebo zobrazení není. Existuje další kontroler, který zpracovává mírně odlišný scénář zahrnující odkazy na rozpětí: [C26445 NO_SPAN_REF](c26445.md). Obě pravidla mohou přispět k zamezení jemným, ale nebezpečným chybám provedeným při moderním a připravování starší verze kódu.

## <a name="remarks"></a>Poznámky

- Toto pravidlo upozorňuje na místa, kde se konstruktory vyvolají pro rozsahy nebo zobrazení a vyrovnávací paměť zdrojových dat patří do dočasného objektu vytvořeného v rámci stejného příkazu. To zahrnuje:
  - implicitní převody v příkazech Return;
  - implicitní převody v ternárních operátorech;
  - explicitní převody v `static_cast` výrazy;
  - volání funkce, která vracejí kontejnery podle hodnoty.
- Dočasné objekty vytvořené pro argumenty volání funkce nejsou označeny příznakem. Je bezpečné předat rozsahy z takových dočasné objekty, pokud funkce Target neuchovávají datové ukazatele v externích proměnných.
- Pokud jsou rozsahy nebo zobrazení samy dočasné objekty, pravidlo je přeskočí.
- Sledování dat v kontrole má určitá omezení. proto nemusí být manipulováno se složitými scénáři, které zahrnují vícenásobné nebo skryté změny přiřazení.

## <a name="example-subtle-difference-in-result-types"></a>Příklad: drobný rozdíl v typech výsledků

```cpp
// Returns a predefined collection. Keeps data alive.
gsl::span<const sequence_item> get_seed_sequence() noexcept;

// Returns a generated collection. Doesn’t own new data.
const std::vector<sequence_item> get_next_sequence(gsl::span<const sequence_item>);

void run_batch()
{
    auto sequence = get_seed_sequence();
    while (send(sequence))
    {
        sequence = get_next_sequence(sequence); // C26449
        // ...
    }
}
```

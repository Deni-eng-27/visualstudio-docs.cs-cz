---
title: C26403
ms.date: 07/21/2017
ms.topic: conceptual
f1_keywords:
- C26403
helpviewer_keywords:
- C26403
ms.assetid: 7e14868d-df86-4df3-98d3-71b1e80ba14e
author: mikeblome
ms.author: mblome
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: 2e1fc2b256bae5459d58d3ba86a642848a12f060
ms.sourcegitcommit: 535ef05b1e553f0fc66082cd2e0998817eb2a56a
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 10/07/2019
ms.locfileid: "72011855"
---
# <a name="c26403-reset_or_delete_owner"></a>C26403 RESET_OR_DELETE_OWNER

Ukazatelé vlastníka jsou jako jedineční ukazatelé: vlastní prostředky výhradně a spravují vydanou verzi prostředku a také jejich přenosy na jiné vlastníky. Tato kontrola ověří, že ukazatel místního vlastníka správně udržuje svůj prostředek prostřednictvím všech cest provádění ve funkci. Pokud se prostředek nepřenesl na jiného vlastníka nebo nebyl explicitně vydán, kontrola se upozorní a odkazuje na deklaraci proměnné ukazatele.

Další informace najdete v [ C++ základních pokynech](http://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#r-resource-management).

## <a name="remarks"></a>Poznámky

- V současné době tato kontrolu neposkytuje přesnou cestu, která nedokáže uvolnit prostředek. Toto chování je možné v budoucích verzích zlepšit. Může být obtížné najít přesné umístění opravy. Lepším řešením je vyzkoušení jednoduchých ukazatelů v komplexních funkcích s jedinečnými ukazateli, aby se předešlo jakýmkoli rizikům.

- Tato operace může zahodit přenesené funkce, aby neblokovala analýzu kódu. Obecně platí, že složitost funkcí by měla být udržována pod určitou rozumnou prahovou hodnotou. V C++ případě, že je pro ni jasné vyžádání, můžeme zvážit přidání místní kontroly složitosti do modulu Core Core. Toto omezení se vztahuje na další pravidla, která jsou citlivá na tok dat.

- Upozornění může vyvolávat jasně falešně pozitivní případy, kdy je paměť odstraněna pouze po kontrole hodnoty NULL ukazatele. Toto je výsledek aktuálního omezení rozhraní API nástroje, ale může být v budoucnu vylepšený.

## <a name="example-1-missing-cleanup-during-error-handling"></a>Příklad 1: Při zpracování chyb chybí vyčištění.

```cpp
gsl::owner<int*> sequence = GetRandomSequence(); // C26403

try
{
    StartSimulation(sequence);
}
catch (const std::exception& e)
{
    if (KnownException(e))
        return; // Skipping the path which deletes the owner.

    ReportException(e);
}

delete [] sequence;
```

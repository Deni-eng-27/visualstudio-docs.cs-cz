---
title: C26403
ms.date: 07/21/2017
ms.topic: conceptual
f1_keywords:
- C26403
helpviewer_keywords:
- C26403
ms.assetid: 7e14868d-df86-4df3-98d3-71b1e80ba14e
author: corob-msft
ms.author: corob
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: af52b92127e91cfc10b4e36ed72299eff7289450
ms.sourcegitcommit: 68f893f6e472df46f323db34a13a7034dccad25a
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 02/15/2020
ms.locfileid: "77261342"
---
# <a name="c26403-reset_or_delete_owner"></a>C26403 RESET_OR_DELETE_OWNER

Ukazatelé vlastníka jsou jako jedineční ukazatelé: vlastní prostředky výhradně a spravují vydanou verzi prostředku a také jejich přenosy na jiné vlastníky. Tato kontrola ověří, že ukazatel místního vlastníka správně udržuje svůj prostředek prostřednictvím všech cest provádění ve funkci. Pokud se prostředek nepřenesl na jiného vlastníka nebo nebyl explicitně vydán, kontrola se upozorní a odkazuje na deklaraci proměnné ukazatele.

Další informace najdete v [ C++ základních pokynech](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#r-resource-management).

## <a name="remarks"></a>Poznámky

- V současné době tato kontrolu neposkytuje přesnou cestu, která nedokáže uvolnit prostředek. Toto chování je možné v budoucích verzích zlepšit. Může být obtížné najít přesné umístění opravy. Lepším řešením je vyzkoušení jednoduchých ukazatelů v komplexních funkcích s jedinečnými ukazateli, aby se předešlo jakýmkoli rizikům.

- Tato operace může zahodit přenesené funkce, aby neblokovala analýzu kódu. Obecně platí, že složitost funkcí by měla být udržována pod určitou rozumnou prahovou hodnotou. V C++ případě, že je pro ni jasné vyžádání, můžeme zvážit přidání místní kontroly složitosti do modulu Core Core. Toto omezení se vztahuje na další pravidla, která jsou citlivá na tok dat.

- Upozornění může vyvolávat jasně falešně pozitivní případy, kdy je paměť odstraněna pouze po kontrole hodnoty NULL ukazatele. Toto je výsledek aktuálního omezení rozhraní API nástroje, ale může být v budoucnu vylepšený.

## <a name="example-1-missing-cleanup-during-error-handling"></a>Příklad 1: chybějící vyčištění během zpracování chyby

```cpp
gsl::owner<int*> sequence = GetRandomSequence(); // C26403

try
{
    StartSimulation(sequence);
}
catch (const std::exception& e)
{
    if (KnownException(e))
        return; // Skipping the path which deletes the owner.

    ReportException(e);
}

delete [] sequence;
```

---
title: Upozornění zabezpečení
ms.date: 10/02/2019
ms.topic: reference
f1_keywords:
- vs.codeanalysis.securityrules
helpviewer_keywords:
- security [Visual Studio ALM], Enterprise Templates
- security warnings
- managed code analysis warnings, security warnings
- warnings, security
ms.assetid: 60d4e8ea-230a-494f-aa6a-b91db77540e4
author: gewarren
ms.author: gewarren
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 52ddee2e876576508573fbadedcc407f81703e18
ms.sourcegitcommit: 9f6f63a2d76c6e579b4b67a96ec86faba99ad1df
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 10/03/2019
ms.locfileid: "71933119"
---
# <a name="security-warnings"></a>Upozornění zabezpečení

Upozornění zabezpečení podporují bezpečnější knihovny a aplikace. Tato upozornění pomáhají zabránit chybám zabezpečení v programu. Pokud některá z těchto upozornění zakážete, měli byste v kódu jasně označit důvod a také informovat bezpečnostního úředníka vývoje projektu.

## <a name="in-this-section"></a>V tomto oddílu

|Pravidlo|Popis|
|----------|-----------------|
|[CA2100: Kontrola dotazů SQL na chyby zabezpečení](../code-quality/ca2100-review-sql-queries-for-security-vulnerabilities.md)|Metoda nastavuje vlastnost System.Data.IDbCommand.CommandText pomocí řetězce, který je sestaven z řetězcového argumentu k metodě. Toto pravidlo předpokládá, že řetězcový argument obsahuje vstup uživatele. Řetězec příkazu SQL sestavený ze vstupu uživatele je ohrožen útoky prostřednictvím injektáže SQL.|
|[CA2102: Zachytávání výjimek bez CLSCompliant v obecných obslužných rutinách](../code-quality/ca2102-catch-non-clscompliant-exceptions-in-general-handlers.md)|Člen v sestavení, které není označeno pomocí atributu RuntimeCompatibilityAttribute nebo je označeno atributem RuntimeCompatibility(WrapNonExceptionThrows = false), obsahuje zachytávací blok, který zpracovává typ System.Exception a neobsahuje bezprostředně následující obecný zachytávací blok.|
|[CA2103: Kontrola imperativního zabezpečení](../code-quality/ca2103-review-imperative-security.md)|Metoda používá imperativní zabezpečení a může vytvářet oprávnění pomocí informací o stavu nebo návratových hodnot, které se mohou změnit, pokud je žádost aktivní. Používejte deklarativní zabezpečení vždy, když je to možné.|
|[CA2104: Nedeklarujte proměnlivé odkazové typy pouze pro čtení](../code-quality/ca2104-do-not-declare-read-only-mutable-reference-types.md)|Externě viditelný typ obsahuje externě viditelné pole měnitelného referenčního typu, které je určeno jen pro čtení. Měnitelný typ je typ, jehož instanční data lze upravit.|
|[CA2105: Pole polí by neměly být pouze pro čtení](../code-quality/ca2105-array-fields-should-not-be-read-only.md)|Když použijete modifikátor jen pro čtení (jen pro čtení v Visual Basic) na pole, které obsahuje pole, nelze změnit pole tak, aby odkazovalo na jiné pole. Avšak prvky pole, které jsou uloženy v poli určeném jen pro čtení, mohou být změněny.|
|[CA2106: Zabezpečit kontrolní výrazy](../code-quality/ca2106-secure-asserts.md)|Metoda uplatňuje oprávnění a na volajícím nejsou vykonány žádné kontroly zabezpečení. Uplatnění oprávnění zabezpečení bez provedení jakékoliv kontroly zabezpečení může zanechat ve vašem kódu zneužitelné slabé stránky zabezpečení.|
|[CA2107: Kontrola použití při odepření a povolení](../code-quality/ca2107-review-deny-and-permit-only-usage.md)|Pomocí metody PermitOnly a akcí zabezpečení CodeAccessPermission. Deny by se měly používat jenom ty, které mají pokročilé znalosti zabezpečení .NET. Kód používající tyto bezpečnostní akce by měl být podroben revizi zabezpečení.|
|[CA2108: Kontrola deklarativních zabezpečení na hodnotových typech](../code-quality/ca2108-review-declarative-security-on-value-types.md)|Veřejný nebo chráněný hodnotový typ je zabezpečen pomocí přístupu k datům nebo požadavků propojení.|
|[CA2109: Kontrola viditelných obslužných rutin událostí](../code-quality/ca2109-review-visible-event-handlers.md)|Byla zjištěna veřejná nebo chráněná metoda zpracování událostí. Metody zpracování událostí by neměly být vystaveny, pokud to není nezbytně nutné.|
|[CA2111: Ukazatelé by neměli být viditelné](../code-quality/ca2111-pointers-should-not-be-visible.md)|Ukazatel není soukromý, interní nebo jen pro čtení. Škodlivý kód může změnit hodnotu ukazatele, což potenciálně umožňuje přístup do libovolného umístění v paměti nebo může způsobit selhání aplikace nebo systému.|
|[CA2112: Zabezpečené typy by neměly vystavovat pole](../code-quality/ca2112-secured-types-should-not-expose-fields.md)|Veřejný nebo chráněný typ obsahuje veřejná pole a je zabezpečen pomocí požadavků propojení. Pokud má kód přístup k instanci typu, která je zabezpečena pomocí požadavku na propojení, nemusí kód vyhovět požadavku na propojení pro přístup k polím tohoto typu.|
|[CA2114: Zabezpečení metody by mělo být nadmnožinou typu](../code-quality/ca2114-method-security-should-be-a-superset-of-type.md)|Metoda by neměla mít pro stejnou akci deklarativní zabezpečení jak na úrovni metody, tak na úrovni typu.|
|[CA2115: Vyvolejte GC. Udržení naživu při použití nativních prostředků](../code-quality/ca2115-call-gc-keepalive-when-using-native-resources.md)|Toto pravidlo zjistí chyby, které mohou nastat, protože nespravovaný prostředek je finalizován v době, kdy je stále používán nespravovaným kódem.|
|[CA2116: Metody APTCA by měly volat pouze metody APTCA](../code-quality/ca2116-aptca-methods-should-only-call-aptca-methods.md)|Když je atribut APTCA (AllowPartiallyTrustedCallers) uveden pro plně důvěryhodná sestavení a sestavení spustí kód v jiném sestavení, které nepovoluje částečně důvěryhodné volající, může se jednat o chybu v zabezpečení.|
|[CA2117: Typy APTCA by měly rozšířily pouze základní typy APTCA](../code-quality/ca2117-aptca-types-should-only-extend-aptca-base-types.md)|Když je atribut APTCA (AllowPartiallyTrustedCallers) uveden pro plně důvěryhodná sestavení a typ v sestavení je odvozen z typu, který nepovoluje částečně důvěryhodné volající, může se jednat o chybu v zabezpečení.|
|[CA2118: Kontrola využití SuppressUnmanagedCodeSecurityAttribute](../code-quality/ca2118-review-suppressunmanagedcodesecurityattribute-usage.md)|Atribut SuppressUnmanagedCodeSecurityAttribute mění výchozí chování zabezpečení systému pro členy vykonávající nespravovaný kód, který používá zprostředkovatele komunikace s objekty COM nebo vyvolání platformy. Tento atribut slouží především ke zvýšení výkonu, ačkoliv nárůst výkonu může být spojen s významnými riziky zabezpečení.|
|[CA2119: Metody zapečetění, které odpovídají privátním rozhraním](../code-quality/ca2119-seal-methods-that-satisfy-private-interfaces.md)|Dědičný veřejný typ poskytuje implementaci přepsatelné metody interního (Friend v Visual Basic) rozhraní. Chcete-li opravit porušení tohoto pravidla, zabraňte přepsání metody mimo sestavení.|
|[CA2120: Zabezpečené konstruktory serializace](../code-quality/ca2120-secure-serialization-constructors.md)|Tento typ má konstruktor, který přebírá objekt System.Runtime.Serialization.SerializationInfo a objekt System.Runtime.Serialization.StreamingContext (podpis serializace konstruktoru). Tento konstruktor není zabezpečen pomocí kontroly zabezpečení, ale jeden nebo více běžných konstruktorů tohoto typu je zabezpečených.|
|[CA2121: Statické konstruktory by měly být privátní.](../code-quality/ca2121-static-constructors-should-be-private.md)|Systém volá statický konstruktor před vytvořením první instance typu nebo předtím, než jsou odkazovány jakékoli statické členy. Pokud statický konstruktor není soukromý, může být volán jiným kódem než kódem systému. V závislosti na operacích, které jsou provedeny v konstruktoru, to může způsobit neočekávané chování.|
|[CA2122: Nezveřejňujte nepřímo metody s požadavky propojení](../code-quality/ca2122-do-not-indirectly-expose-methods-with-link-demands.md)|Veřejný nebo chráněný člen má požadavky propojení a je volán členem, který neprovádí žádné bezpečnostní kontroly. Požadavek propojení kontroluje pouze oprávnění bezprostředního volajícího.|
|[CA2123: Požadavky na přepsání odkazu by měly být shodné se základem](../code-quality/ca2123-override-link-demands-should-be-identical-to-base.md)|Toto pravidlo přiřazuje metodu své základní metodě, kterou je buď rozhraní, nebo virtuální metoda jiného typu, a poté v obou metodách srovnává požadavky propojení. Je-li toto pravidlo porušeno, může chybný volající obejít požadavek propojení pouhým voláním nezabezpečené metody.|
|[CA2124: Zalamovat nezranitelné klauzule finally ve vnějším pokusu](../code-quality/ca2124-wrap-vulnerable-finally-clauses-in-outer-try.md)|Veřejná nebo chráněná metoda obsahuje blok try/finally. Blok finally nejspíše obnovuje stav zabezpečení a sám není uzavřen v bloku finally.|
|[CA2126 Požadavky na propojení typů vyžadují dědičnost požadavků](../code-quality/ca2126-type-link-demands-require-inheritance-demands.md)|Veřejný nezapečetěný typ je chráněn pomocí požadavku propojení a má přepisovatelnou metodu. Tento typ ani tato metoda nejsou chráněny pomocí vyžádané dědičnosti.|
|[CA2130: Konstanty kritické pro zabezpečení by měly být transparentní](../code-quality/ca2130-security-critical-constants-should-be-transparent.md)|Pro konstantní hodnoty není vynucována transparentnost, protože kompilátory vkládají konstantní hodnoty do kódu, aby za běhu programu nebylo zapotřebí žádné vyhledávání. Konstantní pole by měla být transparentní z pohledu zabezpečení, aby kontroloři kódu nepředpokládali, že transparentní kód nemůže ke konstantě přistoupit.|
|[CA2131: Typy kritické pro zabezpečení se nemůžou účastnit rovnocennosti typů.](../code-quality/ca2131-security-critical-types-may-not-participate-in-type-equivalence.md)|Typ se účastní ekvivalentu typu a buď samotný typ, nebo člen nebo pole typu, je označen atributem SecurityCriticalAttribute. Toto pravidlo je vyvoláno pro všechny kritické typy nebo typy obsahující kritické metody nebo pole, která se účastní porovnávání typů. Zjistí-li modul CLR takový typ, jeho načtení za běhu se nezdaří a je vyvolána výjimka TypeLoadException. Obvykle ke spuštění tohoto pravidla dochází pouze v případě, že uživatel implementuje porovnávání typů ručně a nepřenechává porovnávání typů na nástroji tlbimp a kompilátorech.|
|[CA2132: Výchozí konstruktory musí být alespoň tak kritické jako výchozí konstruktory základního typu.](../code-quality/ca2132-default-constructors-must-be-at-least-as-critical-as-base-type-default-constructors.md)|Typy a členy, které mají atribut SecurityCriticalAttribute, nelze použít kódem aplikace Silverlight. Typy a členy kritické z hlediska zabezpečení lze použít pouze prostřednictvím důvěryhodného kódu v knihovně tříd rozhraní .NET Framework aplikace Silverlight. Protože veřejné nebo chráněné konstrukce v odvozené třídě musí mít stejnou nebo větší transparentnost než jejich základní třída, nelze třídu v aplikaci odvodit z třídy označené jako SecurityCritical.|
|[CA2133: Delegáti musí být vázáni k metodám s konzistentní transparentností](../code-quality/ca2133-delegates-must-bind-to-methods-with-consistent-transparency.md)|Toto upozornění je vyvoláno na metodě, která vytvoří vazbu delegáta označeného atributem SecurityCriticalAttribute na transparentní metodu nebo metodu označenou atributem SecuritySafeCriticalAttribute. Upozornění je také vyvoláno na metodě, která vytvoří vazbu transparentního delegáta nebo bezpečně kritického delegáta na kritickou metodu.|
|[CA2134: Metody musí při přepisování základních metod zachovávat konzistentní transparentnost.](../code-quality/ca2134-methods-must-keep-consistent-transparency-when-overriding-base-methods.md)|Toto pravidlo je vyvoláno, když metoda označená atributem SecurityCriticalAttribute přepíše transparentní metodu nebo metodu označenou atributem SecuritySafeCriticalAttribute. Toto pravidlo je vyvoláno, když transparentní metoda nebo metoda označená atributem SecuritySafeCriticalAttribute přepíše metodu označenou atributem SecurityCriticalAttribute. Pravidlo je použito při přepisování virtuální metody nebo implementaci rozhraní.|
|[CA2135: Sestavení úrovně 2 by neměla obsahovat LinkDemands](../code-quality/ca2135-level-2-assemblies-should-not-contain-linkdemands.md)|Pravidla LinkDemand jsou v sadě pravidel zabezpečení úrovně 2 již zastaralá. Namísto použití pravidel LinkDemand k vynucení zabezpečení v době kompilace JIT označte metody, typy a pole pomocí atributu SecurityCriticalAttribute.|
|[CA2136: Členové by neměli mít konfliktní poznámky transparentnosti](../code-quality/ca2136-members-should-not-have-conflicting-transparency-annotations.md)|Atributy transparentnosti jsou použity z prvků kódu většího rozsahu na prvky menšího rozsahu. Atributy transparentnosti prvků kódu, které mají větší rozsah, mají přednost před atributy transparentnosti prvků kódu, které jsou obsaženy v prvním prvku. Například třída označená atributem SecurityCriticalAttribute nemůže obsahovat metodu, která je označena atributem SecuritySafeCriticalAttribute.|
|[CA2137: Transparentní metody musí obsahovat jenom ověřitelný IL.](../code-quality/ca2137-transparent-methods-must-contain-only-verifiable-il.md)|Metoda obsahuje kód, který nelze ověřit, nebo vrací typ odkazem. Toto pravidlo je vyvoláno při pokusech transparentního kódu zabezpečení spustit jazyk MSIL (Microsoft Intermediate Language), který nelze ověřit. Pravidlo však neobsahuje úplný ověřovatel jazyka IL a místo toho k zachycení většiny porušení ověření jazyka MSIL používá heuristiky.|
|[CA2138: Transparentní metody nesmí volat metody s atributem SuppressUnmanagedCodeSecurity.](../code-quality/ca2138-transparent-methods-must-not-call-methods-with-the-suppressunmanagedcodesecurity-attribute.md)|Transparentní metoda zabezpečení volá metodu, která je označena atributem SuppressUnmanagedCodeSecurityAttribute.|
|[CA2139: Transparentní metody nemůžou používat atribut HandleProcessCorruptingExceptions.](../code-quality/ca2139-transparent-methods-may-not-use-the-handleprocesscorruptingexceptions-attribute.md)|Toto pravidlo je vyvoláno na jakékoli metodě, která je transparentní a pokusí se zpracovat výjimku při poškození procesu pomocí atributu HandleProcessCorruptedStateExceptionsAttribute. Výjimka poškození procesu je klasifikace výjimek verze 4,0, jako je například <xref:System.AccessViolationException>. Atribut HandleProcessCorruptedStateExceptionsAttribute lze použít pouze metodami kritickými pro bezpečnost a bude ignorován, je-li použit u transparentních metod.|
|[CA2140: Transparentní kód nesmí odkazovat na položky kritické pro zabezpečení.](../code-quality/ca2140-transparent-code-must-not-reference-security-critical-items.md)|Metody označené pomocí atributu SecurityTransparentAttribute volají neveřejné členy, které jsou označené jako SecurityCritical. Toto pravidlo analyzuje všechny metody a typy v sestavení, které je transparentní a kritické, a označí všechna volání z transparentního kódu do neveřejného kritického kódu, která nejsou označena jako SecurityTreatAsSafe.|
|[CA2141:Transparentní metody nesmějí vyhovovat LinkDemands](../code-quality/ca2141-transparent-methods-must-not-satisfy-linkdemands.md)|Transparentní metoda (z hlediska zabezpečení) volá metodu v sestavení, které není označeno atributem AllowPartiallyTrustedCallersAttribute (APTCA), nebo transparentní metoda (z hlediska zabezpečení) splňuje pravidlo LinkDemand pro typ nebo metodu.|
|[CA2142: Transparentní kód by neměl být chráněn pomocí LinkDemands](../code-quality/ca2142-transparent-code-should-not-be-protected-with-linkdemands.md)|Toto pravidlo je vyvoláno na transparentních metodách, které vyžadují pro přístup k nim pravidla LinkDemand. Kód transparentní z hlediska zabezpečení by neměl být odpovědný za ověření zabezpečení operace, a proto by neměl požadovat oprávnění.|
|[CA2143: Transparentní metody by neměly používat požadavky zabezpečení](../code-quality/ca2143-transparent-methods-should-not-use-security-demands.md)|Kód transparentní z hlediska zabezpečení by neměl být odpovědný za ověření zabezpečení operace, a proto by neměl požadovat oprávnění. Kód transparentní z hlediska zabezpečení by měl k učinění rozhodnutí o zabezpečení používat úplné požadavky a bezpečně kritický kód by neměl spoléhat na to, že transparentní kód tyto úplné požadavky provede.|
|[CA2144: Transparentní kód by neměl načítat sestavení z bajtových polí](../code-quality/ca2144-transparent-code-should-not-load-assemblies-from-byte-arrays.md)|Přezkoumání zabezpečení transparentního kódu není tak důsledné jako přezkoumání zabezpečení kritického kódu, protože transparentní kód nemůže provádět akce citlivé na zabezpečení. Sestavení, která jsou načtena z pole bajtů, nemusí být v transparentním kódu zaznamenána a takové pole bajtů může obsahovat kritický nebo důležitější bezpečně kritický kód, který musí být auditován.|
|[CA2145: Transparentní metody by neměly být dekorované pomocí SuppressUnmanagedCodeSecurityAttribute](../code-quality/ca2145-transparent-methods-should-not-be-decorated-with-the-suppressunmanagedcodesecurityattribute.md)|Metody označené atributem SuppressUnmanagedCodeSecurityAttribute mají implicitní pravidlo LinkDemand umístěné na jakoukoli metodu, která je volá. Tento LinkDemand vyžaduje, aby byl volající kód kritický z hlediska zabezpečení. Označení metody, která používá SuppressUnmanagedCodeSecurity, atributem SecurityCriticalAttribute zviditelňuje tento požadavek pro volající metody.|
|[CA2146: Typy musí být alespoň tak kritické jako jejich základní typy a rozhraní.](../code-quality/ca2146-types-must-be-at-least-as-critical-as-their-base-types-and-interfaces.md)|Toto pravidlo je vyvoláno, když má odvozený typ atribut transparentnosti zabezpečení, který není tak kritický jako jeho základní typ nebo implementované rozhraní. Pouze kritické typy lze odvodit z kritických základních typů nebo mohou implementovat kritická rozhraní a pouze kritické typy nebo bezpečně kritické typy mohou být odvozeny ze základních bezpečně kritických typů nebo mohou implementovat bezpečně kritická rozhraní.|
|[CA2147: Transparentní metody nemůžou používat kontrolní výrazy zabezpečení.](../code-quality/ca2147-transparent-methods-may-not-use-security-asserts.md)|Toto pravidlo analyzuje všechny metody a typy v sestavení, které je buď 100% transparentní, nebo smíšené transparentní/kritické, a označí všechny deklarativní nebo imperativní použití výrazu Assert.|
|[CA2149: Transparentní metody nesmí volat do nativního kódu.](../code-quality/ca2149-transparent-methods-must-not-call-into-native-code.md)|Toto pravidlo je vyvoláno na jakékoli transparentní metodě, která volá přímo do nativního kódu, například prostřednictvím volání nespravovaného kódu. Porušení tohoto pravidla vede k vyvolání výjimky MethodAccessException v modelu transparentnosti úrovně 2 a k úplnému požadavku na nespravovaný kód v modelu transparentnosti úrovně 1.|
|[CA2151: Pole s kritickými typy by měla být kritická zabezpečení](../code-quality/ca2151-fields-with-critical-types-should-be-security-critical.md)|Chcete-li používat typy kritické z hlediska zabezpečení, musí být kód, který odkazuje na typ, buď kritický z hlediska zabezpečení, nebo bezpečně kritický z hlediska zabezpečení. To platí i v případě, že je odkaz nepřímý. Proto je existence transparentního pole kritického z hlediska zabezpečení nebo transparentního pole bezpečně kritického z hlediska zabezpečení zavádějící, jelikož transparentní kód nebude mít k poli přístup.|
|[CA5122: Deklarace volání nespravovaného kódu nesmí být kritické pro zabezpečení](../code-quality/ca5122-p-invoke-declarations-should-not-be-safe-critical.md)|Metody jsou při provádění operace citlivé na zabezpečení označeny jako SecuritySafeCritical, ale lze je také bezpečně použít transparentním kódem. Transparentní kód nesmí nikdy přímo volat nativní kód prostřednictvím P/Invoke. Proto označení P/Invoke jako bezpečně kritické z hlediska zabezpečení neumožní transparentnímu kódu vyvolat je a je zavádějící pro analýzu zabezpečení.|
|[CA2153: Vyhněte se zpracování výjimek poškozených stavů @ no__t-0|[Poškozené výjimky stavu (rozšíření)](https://msdn.microsoft.com/magazine/dd419661.aspx) označují, že v procesu existuje poškození paměti. Pokud by útočník mohl zneužít do poškozené oblasti paměti, může to místo toho zachytit, než umožní selhání procesu způsobit chyby zabezpečení.|
|[CA3075: Nezabezpečené zpracování DTD @ no__t-0|Pokud používáte nezabezpečené instance DTDProcessing nebo odkazujete na zdroje externích entit, může analyzátor přijmout nedůvěryhodné vstupní a únik citlivých informací útočníkům.|
|[CA3076: Nezabezpečený běh skriptu XSLT @ no__t-0|Pokud v aplikacích .NET nezabezpečeně vyplníte Extensible Stylesheet Language Transformers (XSLT), může procesor vyřešit nedůvěryhodné odkazy identifikátorů URI, které by mohly zveřejnit citlivé informace pro útočníky, což by způsobilo odepření služby a vzájemného pracoviště. ohrožující.|
|[CA3077: Nezabezpečené zpracování v návrhu rozhraní API, dokumentu XML a čtečce textu XML @ no__t-0|Při navrhování rozhraní API odvozeného z XMLDocument a XMLTextReader nezapomeňte na DtdProcessing. Použití nezabezpečených instancí DTDProcessing při odkazování na zdroje externích entit nebo jejich překládání na nezabezpečené hodnoty v XML může vést k odhalení informací.|
|[CA3147: Označit obslužné rutiny operací pomocí ValidateAntiForgeryToken @ no__t-0|Při navrhování kontroleru ASP.NET MVC si zajistěte útoky proti falšování požadavků mezi lokalitami. Útok proti padělání žádostí mezi servery může odesílat škodlivé požadavky od ověřeného uživatele do kontroleru ASP.NET MVC.|
|@NO__T – 0CA5361: Nepovolujte použití SChannel silné šifry @ no__t-0|Nastavení `Switch.System.Net.DontEnableSchUseStrongCrypto` pro`true` oslabení kryptografie používané v odchozích připojeních TLS (Transport Layer Security). Slabší kryptografie může ohrozit důvěrnost komunikace mezi vaší aplikací a serverem, což usnadňuje útočníkům eavesdrop citlivá data.|
|@NO__T – 0CA5363: Nepovolujte ověření žádosti @ no__t-0|Ověření žádosti je funkce v ASP.NET, která prověřuje požadavky HTTP a určuje, jestli obsahují potenciálně nebezpečný obsah, který může vést k útokům prostřednictvím injektáže, včetně skriptování mezi weby.|
|[CA5364: Nepoužívat zastaralé protokoly zabezpečení](../code-quality/ca5364.md)|Protokol TLS (Transport Layer Security) zabezpečuje komunikaci mezi počítači, nejčastěji s protokolem HTTPS (Hypertext Transfer Protocol Secure). Starší verze protokolu TLS jsou méně bezpečné než TLS 1,2 a TLS 1,3 a je pravděpodobnější, že dojde k novým chybám zabezpečení. Nepoužívejte starší verze protokolu pro minimalizaci rizik.|
|@NO__T – 0CA5369: Použít XmlReader pro deserializaci @ no__t-0|Zpracování nedůvěryhodných schémat DTD a XML může povolit načítání nebezpečných externích odkazů, které by měly být omezeny pomocí objektu XmlReader s zabezpečeným překladačem nebo se zakázaným zpracováním vloženého schématu DTD a XML.|
|@NO__T – 0CA5370: Použití XmlReader k ověření čtecího zařízení @ no__t-0|Zpracování nedůvěryhodných schémat DTD a XML může povolit načítání nebezpečných externích odkazů. Toto nebezpečné načítání může být omezeno pomocí objektu XmlReader s zabezpečeným překladačem nebo zpracováním vloženého schématu DTD a XML.|
|@NO__T – 0CA5371: Použít XmlReader pro schéma Read @ no__t-0|Zpracování nedůvěryhodných schémat DTD a XML může povolit načítání nebezpečných externích odkazů. Použití objektu XmlReader s zabezpečeným překladačem nebo zpracováním vloženého schématu DTD a XML je zakázané.|
|@NO__T – 0CA5372: Použít XmlReader pro XPathDocument @ no__t-0|Zpracování XML z nedůvěryhodných dat může načítat nebezpečné externí odkazy, které mohou být omezeny pomocí objektu XmlReader s zabezpečeným překladačem nebo zakázaným zpracováním DTD.|
|@NO__T – 0CA5373: Nepoužívat zastaralou funkci odvození klíče @ no__t-0|Toto pravidlo detekuje vyvolání slabé metody <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> odvození klíče a. `Rfc2898DeriveBytes.CryptDeriveKey` <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName>používal se slabší PBKDF1 algoritmu.|
|@NO__T – 0CA5378: Nezakažte ServicePointManagerSecurityProtocols @ no__t-0|Nastavení `Switch.System.ServiceModel.DisableUsingServicePointManagerSecurityProtocols` pro`true` omezení připojení TLS (Transport Layer Security) technologie Windows Communication Framework (TLS) k použití protokolu TLS 1,0. Tato verze TLS bude zastaralá.|
|@NO__T – 0CA5380: Nepřidávat certifikáty do kořenového úložiště @ no__t-0|Toto pravidlo detekuje kód, který přidá certifikát do úložiště certifikátů důvěryhodných kořenových certifikačních autorit. Ve výchozím nastavení je úložiště certifikátů důvěryhodných kořenových certifikačních autorit nakonfigurováno se sadou veřejných certifikačních autorit, které splnily požadavky programu Microsoft Root Certificate Program.|
|@NO__T – 0CA5381: Zajistěte, aby se certifikáty do kořenového úložiště nepřidaly. @ no__t-0|Toto pravidlo detekuje kód, který potenciálně přidá certifikát do úložiště certifikátů důvěryhodných kořenových certifikačních autorit. Ve výchozím nastavení je úložiště certifikátů důvěryhodných kořenových certifikačních autorit nakonfigurováno se sadou veřejných certifikačních autorit (CA), které splnily požadavky programu Microsoft Root Certificate Program.|
|[CA5386: Vyhněte se hodnotě zakódujeme SecurityProtocolType](../code-quality/ca5386.md)|Protokol TLS (Transport Layer Security) zabezpečuje komunikaci mezi počítači, nejčastěji s protokolem HTTPS (Hypertext Transfer Protocol Secure). Verze protokolu TLS 1,0 a TLS 1,1 jsou zastaralé, zatímco protokol TLS 1,2 a TLS 1,3 jsou aktuální. V budoucnu může být TLS 1,2 a TLS 1,3 zastaralá. Aby se zajistilo, že vaše aplikace zůstane v bezpečí, vyhněte se zakódujeme verze protokolu a cílit aspoň na 4.7.1 .NET Framework v.|
|@NO__T – 0CA5389: Nepřidávat cestu položky archivu do cílové cesty k systému souborů @ no__t-0|Cesta k souboru může být relativní a může vést k přístupu k systému souborů mimo očekávanou cílovou cestu systému souborů, což vede ke škodlivým změnám konfigurace a ke vzdálenému spuštění kódu prostřednictvím techniky stanovení a čekání.|
|[CA5397: Nepoužívat zastaralé hodnoty SslProtocols určující](../code-quality/ca5397.md)|ransport Layer Security (TLS) zabezpečuje komunikaci mezi počítači, nejčastěji s protokolem HTTPS (Hypertext Transfer Protocol Secure). Starší verze protokolu TLS jsou méně bezpečné než TLS 1,2 a TLS 1,3 a je pravděpodobnější, že dojde k novým chybám zabezpečení. Nepoužívejte starší verze protokolu pro minimalizaci rizik.|
|[CA5398: Vyhněte se hodnotám pevně zakódované SslProtocols určující](../code-quality/ca5398.md)|Protokol TLS (Transport Layer Security) zabezpečuje komunikaci mezi počítači, nejčastěji s protokolem HTTPS (Hypertext Transfer Protocol Secure). Verze protokolu TLS 1,0 a TLS 1,1 jsou zastaralé, zatímco protokol TLS 1,2 a TLS 1,3 jsou aktuální. V budoucnu může být TLS 1,2 a TLS 1,3 zastaralá. Abyste měli jistotu, že vaše aplikace zůstane v bezpečí, vyhněte se zakódujeme verze protokolu.|

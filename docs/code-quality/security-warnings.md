---
title: Upozornění zabezpečení
ms.date: 10/02/2019
ms.topic: reference
f1_keywords:
- vs.codeanalysis.securityrules
helpviewer_keywords:
- security [Visual Studio ALM], Enterprise Templates
- security warnings
- managed code analysis warnings, security warnings
- warnings, security
ms.assetid: 60d4e8ea-230a-494f-aa6a-b91db77540e4
author: gewarren
ms.author: gewarren
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: bf1f318d8138bb455e965d7df44ae45e192904e3
ms.sourcegitcommit: 535ef05b1e553f0fc66082cd2e0998817eb2a56a
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 10/07/2019
ms.locfileid: "72018764"
---
# <a name="security-warnings"></a>Upozornění zabezpečení

Upozornění zabezpečení podporují bezpečnější knihovny a aplikace. Tato upozornění pomáhají zabránit chybám zabezpečení v programu. Pokud některá z těchto upozornění zakážete, měli byste v kódu jasně označit důvod a také informovat bezpečnostního úředníka vývoje projektu.

## <a name="in-this-section"></a>V tomto oddílu

|Pravidlo|Popis|
|----------|-----------------|
|[CA2100: Zkontrolujte dotazy SQL na chyby zabezpečení @ no__t-0|Metoda nastavuje vlastnost System.Data.IDbCommand.CommandText pomocí řetězce, který je sestaven z řetězcového argumentu k metodě. Toto pravidlo předpokládá, že řetězcový argument obsahuje vstup uživatele. Řetězec příkazu SQL sestavený ze vstupu uživatele je ohrožen útoky prostřednictvím injektáže SQL.|
|[CA2102: Zachytávání výjimek bez CLSCompliant v obecných obslužných rutinách @ no__t-0|Člen v sestavení, které není označeno pomocí atributu RuntimeCompatibilityAttribute nebo je označeno atributem RuntimeCompatibility(WrapNonExceptionThrows = false), obsahuje zachytávací blok, který zpracovává typ System.Exception a neobsahuje bezprostředně následující obecný zachytávací blok.|
|[CA2103: Kontrola imperativního zabezpečení @ no__t-0|Metoda používá imperativní zabezpečení a může vytvářet oprávnění pomocí informací o stavu nebo návratových hodnot, které se mohou změnit, pokud je žádost aktivní. Používejte deklarativní zabezpečení vždy, když je to možné.|
|[CA2104: Nedeklarujte proměnlivé odkazové typy pouze pro čtení @ no__t-0|Externě viditelný typ obsahuje externě viditelné pole měnitelného referenčního typu, které je určeno jen pro čtení. Měnitelný typ je typ, jehož instanční data lze upravit.|
|[CA2105: Pole polí by neměly být pouze pro čtení @ no__t-0.|Když použijete modifikátor jen pro čtení (jen pro čtení v Visual Basic) na pole, které obsahuje pole, nelze změnit pole tak, aby odkazovalo na jiné pole. Avšak prvky pole, které jsou uloženy v poli určeném jen pro čtení, mohou být změněny.|
|[CA2106: Zabezpečení výrazů @ no__t-0|Metoda uplatňuje oprávnění a na volajícím nejsou vykonány žádné kontroly zabezpečení. Uplatnění oprávnění zabezpečení bez provedení jakékoliv kontroly zabezpečení může zanechat ve vašem kódu zneužitelné slabé stránky zabezpečení.|
|[CA2107: Zkontrolovat použití Deny a povolit pouze použití @ no__t-0|Pomocí metody PermitOnly a akcí zabezpečení CodeAccessPermission. Deny by se měly používat jenom ty, které mají pokročilé znalosti zabezpečení .NET. Kód používající tyto bezpečnostní akce by měl být podroben revizi zabezpečení.|
|[CA2108: Kontrola deklarativního zabezpečení na typech hodnot @ no__t-0|Veřejný nebo chráněný hodnotový typ je zabezpečen pomocí přístupu k datům nebo požadavků propojení.|
|[CA2109: Kontrola viditelných obslužných rutin událostí @ no__t-0|Byla zjištěna veřejná nebo chráněná metoda zpracování událostí. Metody zpracování událostí by neměly být vystaveny, pokud to není nezbytně nutné.|
|[CA2111: Ukazatelé by neměli být viditelné @ no__t-0.|Ukazatel není soukromý, interní nebo jen pro čtení. Škodlivý kód může změnit hodnotu ukazatele, což potenciálně umožňuje přístup do libovolného umístění v paměti nebo může způsobit selhání aplikace nebo systému.|
|[CA2112: Zabezpečené typy by neměly vystavovat pole @ no__t-0|Veřejný nebo chráněný typ obsahuje veřejná pole a je zabezpečen pomocí požadavků propojení. Pokud má kód přístup k instanci typu, která je zabezpečena pomocí požadavku na propojení, nemusí kód vyhovět požadavku na propojení pro přístup k polím tohoto typu.|
|[CA2114: Zabezpečení metody by mělo být nadmnožinou typu @ no__t-0.|Metoda by neměla mít pro stejnou akci deklarativní zabezpečení jak na úrovni metody, tak na úrovni typu.|
|[CA2115: Vyvolejte GC. Udržení naživu při použití nativních prostředků @ no__t-0|Toto pravidlo zjistí chyby, které mohou nastat, protože nespravovaný prostředek je finalizován v době, kdy je stále používán nespravovaným kódem.|
|[CA2116: Metody APTCA by měly volat pouze metody APTCA @ no__t-0|Když je atribut APTCA (AllowPartiallyTrustedCallers) uveden pro plně důvěryhodná sestavení a sestavení spustí kód v jiném sestavení, které nepovoluje částečně důvěryhodné volající, může se jednat o chybu v zabezpečení.|
|[CA2117: Typy APTCA by měly rozšířily pouze základní typy APTCA @ no__t-0|Když je atribut APTCA (AllowPartiallyTrustedCallers) uveden pro plně důvěryhodná sestavení a typ v sestavení je odvozen z typu, který nepovoluje částečně důvěryhodné volající, může se jednat o chybu v zabezpečení.|
|[CA2118: Kontrola využití SuppressUnmanagedCodeSecurityAttribute @ no__t-0|Atribut SuppressUnmanagedCodeSecurityAttribute mění výchozí chování zabezpečení systému pro členy vykonávající nespravovaný kód, který používá zprostředkovatele komunikace s objekty COM nebo vyvolání platformy. Tento atribut slouží především ke zvýšení výkonu, ačkoliv nárůst výkonu může být spojen s významnými riziky zabezpečení.|
|[CA2119: Metody zapečetění, které odpovídají privátním rozhraním @ no__t-0|Dědičný veřejný typ poskytuje implementaci přepsatelné metody interního (Friend v Visual Basic) rozhraní. Chcete-li opravit porušení tohoto pravidla, zabraňte přepsání metody mimo sestavení.|
|[CA2120: Zabezpečené serializace konstruktory @ no__t-0|Tento typ má konstruktor, který přebírá objekt System.Runtime.Serialization.SerializationInfo a objekt System.Runtime.Serialization.StreamingContext (podpis serializace konstruktoru). Tento konstruktor není zabezpečen pomocí kontroly zabezpečení, ale jeden nebo více běžných konstruktorů tohoto typu je zabezpečených.|
|[CA2121: Statické konstruktory by měly být privátní @ no__t-0|Systém volá statický konstruktor před vytvořením první instance typu nebo předtím, než jsou odkazovány jakékoli statické členy. Pokud statický konstruktor není soukromý, může být volán jiným kódem než kódem systému. V závislosti na operacích, které jsou provedeny v konstruktoru, to může způsobit neočekávané chování.|
|[CA2122: Nezveřejňujte nepřímo metody s požadavky propojení @ no__t-0|Veřejný nebo chráněný člen má požadavky propojení a je volán členem, který neprovádí žádné bezpečnostní kontroly. Požadavek propojení kontroluje pouze oprávnění bezprostředního volajícího.|
|[CA2123: Požadavky na přepsání odkazu by měly být shodné se základem @ no__t-0|Toto pravidlo přiřazuje metodu své základní metodě, kterou je buď rozhraní, nebo virtuální metoda jiného typu, a poté v obou metodách srovnává požadavky propojení. Je-li toto pravidlo porušeno, může chybný volající obejít požadavek propojení pouhým voláním nezabezpečené metody.|
|[CA2124: Zalamovat nezranitelné klauzule finally ve vnějším try @ no__t-0|Veřejná nebo chráněná metoda obsahuje blok try/finally. Blok finally nejspíše obnovuje stav zabezpečení a sám není uzavřen v bloku finally.|
|@NO__T – 0CA2126: Požadavky na propojení typů vyžadují dědičnost požadavků @ no__t-0|Veřejný nezapečetěný typ je chráněn pomocí požadavku propojení a má přepisovatelnou metodu. Tento typ ani tato metoda nejsou chráněny pomocí vyžádané dědičnosti.|
|[CA2130: Konstanty kritické pro zabezpečení by měly být transparentní @ no__t-0|Pro konstantní hodnoty není vynucována transparentnost, protože kompilátory vkládají konstantní hodnoty do kódu, aby za běhu programu nebylo zapotřebí žádné vyhledávání. Konstantní pole by měla být transparentní z pohledu zabezpečení, aby kontroloři kódu nepředpokládali, že transparentní kód nemůže ke konstantě přistoupit.|
|[CA2131: Typy kritické pro zabezpečení se nemusí účastnit v rovnosti typů @ no__t-0.|Typ se účastní ekvivalentu typu a buď samotný typ, nebo člen nebo pole typu, je označen atributem SecurityCriticalAttribute. Toto pravidlo je vyvoláno pro všechny kritické typy nebo typy obsahující kritické metody nebo pole, která se účastní porovnávání typů. Zjistí-li modul CLR takový typ, jeho načtení za běhu se nezdaří a je vyvolána výjimka TypeLoadException. Obvykle ke spuštění tohoto pravidla dochází pouze v případě, že uživatel implementuje porovnávání typů ručně a nepřenechává porovnávání typů na nástroji tlbimp a kompilátorech.|
|[CA2132: Výchozí konstruktory musí být alespoň tak kritické jako výchozí konstruktory základního typu @ no__t-0.|Typy a členy, které mají atribut SecurityCriticalAttribute, nelze použít kódem aplikace Silverlight. Typy a členy kritické z hlediska zabezpečení lze použít pouze prostřednictvím důvěryhodného kódu v knihovně tříd rozhraní .NET Framework aplikace Silverlight. Protože veřejné nebo chráněné konstrukce v odvozené třídě musí mít stejnou nebo větší transparentnost než jejich základní třída, nelze třídu v aplikaci odvodit z třídy označené jako SecurityCritical.|
|[CA2133: Delegáti musí být vázáni k metodám s konzistentní transparentností @ no__t-0.|Toto upozornění je vyvoláno na metodě, která vytvoří vazbu delegáta označeného atributem SecurityCriticalAttribute na transparentní metodu nebo metodu označenou atributem SecuritySafeCriticalAttribute. Upozornění je také vyvoláno na metodě, která vytvoří vazbu transparentního delegáta nebo bezpečně kritického delegáta na kritickou metodu.|
|[CA2134: Metody musí při přepisování základních metod zachovávat konzistentní transparentnost. @ no__t-0|Toto pravidlo je vyvoláno, když metoda označená atributem SecurityCriticalAttribute přepíše transparentní metodu nebo metodu označenou atributem SecuritySafeCriticalAttribute. Toto pravidlo je vyvoláno, když transparentní metoda nebo metoda označená atributem SecuritySafeCriticalAttribute přepíše metodu označenou atributem SecurityCriticalAttribute. Pravidlo je použito při přepisování virtuální metody nebo implementaci rozhraní.|
|[CA2135: Sestavení úrovně 2 by neměla obsahovat LinkDemands @ no__t-0.|Pravidla LinkDemand jsou v sadě pravidel zabezpečení úrovně 2 již zastaralá. Namísto použití pravidel LinkDemand k vynucení zabezpečení v době kompilace JIT označte metody, typy a pole pomocí atributu SecurityCriticalAttribute.|
|[CA2136: Členové by neměli mít konfliktní poznámky transparentnosti @ no__t-0|Atributy transparentnosti jsou použity z prvků kódu většího rozsahu na prvky menšího rozsahu. Atributy transparentnosti prvků kódu, které mají větší rozsah, mají přednost před atributy transparentnosti prvků kódu, které jsou obsaženy v prvním prvku. Například třída označená atributem SecurityCriticalAttribute nemůže obsahovat metodu, která je označena atributem SecuritySafeCriticalAttribute.|
|[CA2137: Transparentní metody musí obsahovat jenom ověřitelný IL @ no__t-0.|Metoda obsahuje kód, který nelze ověřit, nebo vrací typ odkazem. Toto pravidlo je vyvoláno při pokusech transparentního kódu zabezpečení spustit jazyk MSIL (Microsoft Intermediate Language), který nelze ověřit. Pravidlo však neobsahuje úplný ověřovatel jazyka IL a místo toho k zachycení většiny porušení ověření jazyka MSIL používá heuristiky.|
|[CA2138: Transparentní metody nesmí volat metody s atributem SuppressUnmanagedCodeSecurity @ no__t-0.|Transparentní metoda zabezpečení volá metodu, která je označena atributem SuppressUnmanagedCodeSecurityAttribute.|
|[CA2139: Transparentní metody nemůžou používat atribut HandleProcessCorruptingExceptions @ no__t-0.|Toto pravidlo je vyvoláno na jakékoli metodě, která je transparentní a pokusí se zpracovat výjimku při poškození procesu pomocí atributu HandleProcessCorruptedStateExceptionsAttribute. Výjimka poškození procesu je klasifikace výjimek verze 4,0, jako je například <xref:System.AccessViolationException>. Atribut HandleProcessCorruptedStateExceptionsAttribute lze použít pouze metodami kritickými pro bezpečnost a bude ignorován, je-li použit u transparentních metod.|
|[CA2140: Transparentní kód nesmí odkazovat na položky kritické pro zabezpečení @ no__t-0.|Metody označené pomocí atributu SecurityTransparentAttribute volají neveřejné členy, které jsou označené jako SecurityCritical. Toto pravidlo analyzuje všechny metody a typy v sestavení, které je transparentní a kritické, a označí všechna volání z transparentního kódu do neveřejného kritického kódu, která nejsou označena jako SecurityTreatAsSafe.|
|[CA2141:Transparentní metody nesmějí vyhovovat LinkDemands](../code-quality/ca2141.md)|Transparentní metoda (z hlediska zabezpečení) volá metodu v sestavení, které není označeno atributem AllowPartiallyTrustedCallersAttribute (APTCA), nebo transparentní metoda (z hlediska zabezpečení) splňuje pravidlo LinkDemand pro typ nebo metodu.|
|[CA2142: Transparentní kód by neměl být chráněn pomocí LinkDemands @ no__t-0.|Toto pravidlo je vyvoláno na transparentních metodách, které vyžadují pro přístup k nim pravidla LinkDemand. Kód transparentní z hlediska zabezpečení by neměl být odpovědný za ověření zabezpečení operace, a proto by neměl požadovat oprávnění.|
|[CA2143: Transparentní metody by neměly používat požadavky na zabezpečení @ no__t-0|Kód transparentní z hlediska zabezpečení by neměl být odpovědný za ověření zabezpečení operace, a proto by neměl požadovat oprávnění. Kód transparentní z hlediska zabezpečení by měl k učinění rozhodnutí o zabezpečení používat úplné požadavky a bezpečně kritický kód by neměl spoléhat na to, že transparentní kód tyto úplné požadavky provede.|
|[CA2144: Transparentní kód by neměl načítat sestavení z bajtových polí @ no__t-0|Přezkoumání zabezpečení transparentního kódu není tak důsledné jako přezkoumání zabezpečení kritického kódu, protože transparentní kód nemůže provádět akce citlivé na zabezpečení. Sestavení, která jsou načtena z pole bajtů, nemusí být v transparentním kódu zaznamenána a takové pole bajtů může obsahovat kritický nebo důležitější bezpečně kritický kód, který musí být auditován.|
|[CA2145: Transparentní metody by neměly být dekorované s použitím SuppressUnmanagedCodeSecurityAttribute @ no__t-0.|Metody označené atributem SuppressUnmanagedCodeSecurityAttribute mají implicitní pravidlo LinkDemand umístěné na jakoukoli metodu, která je volá. Tento LinkDemand vyžaduje, aby byl volající kód kritický z hlediska zabezpečení. Označení metody, která používá SuppressUnmanagedCodeSecurity, atributem SecurityCriticalAttribute zviditelňuje tento požadavek pro volající metody.|
|[CA2146: Typy musí být alespoň tak kritické jako jejich základní typy a rozhraní @ no__t-0.|Toto pravidlo je vyvoláno, když má odvozený typ atribut transparentnosti zabezpečení, který není tak kritický jako jeho základní typ nebo implementované rozhraní. Pouze kritické typy lze odvodit z kritických základních typů nebo mohou implementovat kritická rozhraní a pouze kritické typy nebo bezpečně kritické typy mohou být odvozeny ze základních bezpečně kritických typů nebo mohou implementovat bezpečně kritická rozhraní.|
|[CA2147: Transparentní metody nemůžou používat výrazy zabezpečení @ no__t-0.|Toto pravidlo analyzuje všechny metody a typy v sestavení, které je buď 100% transparentní, nebo smíšené transparentní/kritické, a označí všechny deklarativní nebo imperativní použití výrazu Assert.|
|[CA2149: Transparentní metody nesmí volat do nativního kódu @ no__t-0.|Toto pravidlo je vyvoláno na jakékoli transparentní metodě, která volá přímo do nativního kódu, například prostřednictvím volání nespravovaného kódu. Porušení tohoto pravidla vede k vyvolání výjimky MethodAccessException v modelu transparentnosti úrovně 2 a k úplnému požadavku na nespravovaný kód v modelu transparentnosti úrovně 1.|
|[CA2151: Pole s kritickými typy by měla být kritická zabezpečení @ no__t-0|Chcete-li používat typy kritické z hlediska zabezpečení, musí být kód, který odkazuje na typ, buď kritický z hlediska zabezpečení, nebo bezpečně kritický z hlediska zabezpečení. To platí i v případě, že je odkaz nepřímý. Proto je existence transparentního pole kritického z hlediska zabezpečení nebo transparentního pole bezpečně kritického z hlediska zabezpečení zavádějící, jelikož transparentní kód nebude mít k poli přístup.|
|[CA2153: Vyhněte se zpracování výjimek poškozených stavů @ no__t-0|[Poškozené výjimky stavu (rozšíření)](https://msdn.microsoft.com/magazine/dd419661.aspx) označují, že v procesu existuje poškození paměti. Pokud by útočník mohl zneužít do poškozené oblasti paměti, může to místo toho zachytit, než umožní selhání procesu způsobit chyby zabezpečení.|
|[CA2300: Nepoužívejte nezabezpečený deserializaci BinaryFormatter @ no__t-0|Nezabezpečené deserializace jsou zranitelné při deserializaci nedůvěryhodných dat. Útočník by mohl upravit Serializovaná data tak, aby zahrnovala neočekávané typy pro vložení objektů se škodlivými vedlejšími účinky.|
|[CA2301: Nevolejte BinaryFormatter. deserializovat bez prvotního nastavení BinaryFormatter. Binder @ no__t-0|Nezabezpečené deserializace jsou zranitelné při deserializaci nedůvěryhodných dat. Útočník by mohl upravit Serializovaná data tak, aby zahrnovala neočekávané typy pro vložení objektů se škodlivými vedlejšími účinky.|
|[CA2302: Před voláním BinaryFormatter. deserializace musí být nastaven BinaryFormatter. Binder. @ no__t-0|Nezabezpečené deserializace jsou zranitelné při deserializaci nedůvěryhodných dat. Útočník by mohl upravit Serializovaná data tak, aby zahrnovala neočekávané typy pro vložení objektů se škodlivými vedlejšími účinky.|
|@NO__T – 0CA2305: Nepoužívejte nezabezpečený deserializaci LosFormatter @ no__t-0|Nezabezpečené deserializace jsou zranitelné při deserializaci nedůvěryhodných dat. Útočník by mohl upravit Serializovaná data tak, aby zahrnovala neočekávané typy pro vložení objektů se škodlivými vedlejšími účinky.|
|[CA2310: Nepoužívejte nezabezpečený deserializaci NetDataContractSerializer @ no__t-0|Nezabezpečené deserializace jsou zranitelné při deserializaci nedůvěryhodných dat. Útočník by mohl upravit Serializovaná data tak, aby zahrnovala neočekávané typy pro vložení objektů se škodlivými vedlejšími účinky.|
|[CA2311: Neprovádějte deserializaci bez prvního nastavení NetDataContractSerializer. Binder @ no__t-0|Nezabezpečené deserializace jsou zranitelné při deserializaci nedůvěryhodných dat. Útočník by mohl upravit Serializovaná data tak, aby zahrnovala neočekávané typy pro vložení objektů se škodlivými vedlejšími účinky.|
|[CA2312: Před deserializací @ no__t-0 zajistěte, aby byl soubor NetDataContractSerializer. Binder nastavený.|Nezabezpečené deserializace jsou zranitelné při deserializaci nedůvěryhodných dat. Útočník by mohl upravit Serializovaná data tak, aby zahrnovala neočekávané typy pro vložení objektů se škodlivými vedlejšími účinky.|
|@NO__T – 0CA2315: Nepoužívejte nezabezpečený deserializaci třídě ObjectStateFormatter @ no__t-0|Nezabezpečené deserializace jsou zranitelné při deserializaci nedůvěryhodných dat. Útočník by mohl upravit Serializovaná data tak, aby zahrnovala neočekávané typy pro vložení objektů se škodlivými vedlejšími účinky.|
|[CA2321: Nepoužívejte deserializaci se službou JavaScriptSerializer pomocí SimpleTypeResolver @ no__t-0.|Nezabezpečené deserializace jsou zranitelné při deserializaci nedůvěryhodných dat. Útočník by mohl upravit Serializovaná data tak, aby zahrnovala neočekávané typy pro vložení objektů se škodlivými vedlejšími účinky.|
|[CA2322: Před deserializací @ no__t-0 zajistěte, aby se na SimpleTypeResolver neinicializovala hodnota JavaScriptSerializer.|Nezabezpečené deserializace jsou zranitelné při deserializaci nedůvěryhodných dat. Útočník by mohl upravit Serializovaná data tak, aby zahrnovala neočekávané typy pro vložení objektů se škodlivými vedlejšími účinky.|
|@NO__T – 0CA2326: Nepoužívejte jiné hodnoty TypeNameHandling než None @ no__t-0|Nezabezpečené deserializace jsou zranitelné při deserializaci nedůvěryhodných dat. Útočník by mohl upravit Serializovaná data tak, aby zahrnovala neočekávané typy pro vložení objektů se škodlivými vedlejšími účinky.|
|@NO__T – 0CA2327: Nepoužívejte nezabezpečené JsonSerializerSettings @ no__t-0|Nezabezpečené deserializace jsou zranitelné při deserializaci nedůvěryhodných dat. Útočník by mohl upravit Serializovaná data tak, aby zahrnovala neočekávané typy pro vložení objektů se škodlivými vedlejšími účinky.|
|@NO__T – 0CA2328: Ujistěte se, že JsonSerializerSettings jsou zabezpečené @ no__t-0.|Nezabezpečené deserializace jsou zranitelné při deserializaci nedůvěryhodných dat. Útočník by mohl upravit Serializovaná data tak, aby zahrnovala neočekávané typy pro vložení objektů se škodlivými vedlejšími účinky.|
|@NO__T – 0CA2329: Nepoužívejte deserializaci s JsonSerializer pomocí nezabezpečené konfigurace @ no__t-0.|Nezabezpečené deserializace jsou zranitelné při deserializaci nedůvěryhodných dat. Útočník by mohl upravit Serializovaná data tak, aby zahrnovala neočekávané typy pro vložení objektů se škodlivými vedlejšími účinky.|
|@NO__T – 0CA2330: Ujistěte se, že JsonSerializer má zabezpečenou konfiguraci při deserializaci @ no__t-0.|Nezabezpečené deserializace jsou zranitelné při deserializaci nedůvěryhodných dat. Útočník by mohl upravit Serializovaná data tak, aby zahrnovala neočekávané typy pro vložení objektů se škodlivými vedlejšími účinky.|
|@NO__T – 0CA3001: Přečtěte si kód pro chyby zabezpečení injektáže SQL @ no__t-0|Při práci s nedůvěryhodnými vstupy a příkazy SQL Zajistěte útokům prostřednictvím injektáže SQL. Útok na injektáže SQL může spouštět škodlivé příkazy SQL a ohrozit tak zabezpečení a integritu vaší aplikace.|
|@NO__T – 0CA3002: Přečtěte si kód pro chyby zabezpečení XSS @ no__t-0|Při práci s nedůvěryhodným vstupem z webových požadavků zajistěte útoky skriptování XSS (mezi weby). Útok XSS vloží nedůvěryhodný vstup do nezpracovaného výstupu HTML a umožní útočníkovi spustit škodlivé skripty nebo škodlivým způsobem upravovat obsah na webové stránce.|
|@NO__T – 0CA3003: Kontrola kódu pro chyby zabezpečení vkládání cest k souboru @ no__t-0|Při práci s nedůvěryhodným vstupem z webových požadavků nezapomeňte při zadávání cest k souborům použít vstup, který je řízený uživatelem.|
|@NO__T – 0CA3004: Kontrola kódu pro chyby zabezpečení zpřístupnění informací @ no__t-0|Vydávání informací o výjimce poskytne útočníkům přehled o vnitřních verzích vaší aplikace, které můžou útočníkům pomoci najít další ohrožení zabezpečení pro zneužití.|
|@NO__T – 0CA3006: Přečtěte si kód pro chyby zabezpečení vkládání příkazů procesu @ no__t-0|Při práci s nedůvěryhodným vstupem se zaměříte na útoky vkládání příkazů. Útok injektáže příkazu může spustit škodlivé příkazy v podkladovém operačním systému a ohrozit tak zabezpečení a integritu serveru.|
|@NO__T – 0CA3007: Přečtěte si kód pro otevřené chyby zabezpečení přesměrování @ no__t-0.|Při práci s nedůvěryhodným vstupem nezapomeňte na otevřené chyby zabezpečení přesměrování. Útočník může zneužít otevřenou chybu zabezpečení přesměrování pro použití vašeho webu k poskytnutí vzhledu legitimní adresy URL, ale přesměruje nepodezřelého návštěvníka na podvodný nebo jinou škodlivou webovou stránku.|
|@NO__T – 0CA3008: Přečtěte si kód pro chyby zabezpečení injektáže XPath @ no__t-0|Při práci s nedůvěryhodným vstupem si vědomete útoků prostřednictvím injektáže XPath. Vytváření dotazů XPath pomocí nedůvěryhodného vstupu může útočníkovi umožnit škodlivým způsobem manipulovat s dotazem, aby vrátil nezamýšlený výsledek a případně vyzradit obsah dotazovaného XML.|
|@NO__T – 0CA3009: Kontrola kódu pro chyby zabezpečení injektáže XML @ no__t-0|Při práci s nedůvěryhodným vstupem nezapomeňte na útoky prostřednictvím injektáže XML.|
|@NO__T – 0CA3010: Kontrola kódu pro chyby zabezpečení injektáže XAML @ no__t-0|Při práci s nedůvěryhodným vstupem si vědomete útoků prostřednictvím injektáže XAML. XAML je jazyk značek, který přímo představuje instanci objektu a provádění. To znamená, že prvky vytvořené v jazyce XAML mohou pracovat se systémovými prostředky (například síťový přístup a vstupně-výstupní operace systému souborů).|
|@NO__T – 0CA3011: Kontrola kódu pro chyby zabezpečení vkládání knihoven DLL @ no__t-0|Při práci s nedůvěryhodným vstupem nezapomeňte načíst nedůvěryhodný kód. Pokud vaše webová aplikace načte nedůvěryhodný kód, útočník může být schopen vložit do procesu škodlivé knihovny DLL a spustit škodlivý kód.|
|@NO__T – 0CA3012: Přečtěte si kód pro chyby zabezpečení injektáže regulárního výrazu @ no__t-0|Při práci s nedůvěryhodným vstupem nezapomeňte na útoky pomocí injektáže regulárního výrazu. Útočník může použít injektáže regulárního výrazu pro zlomyslnou úpravu regulárního výrazu, aby regulární výraz odpovídal nezamýšleným výsledkům, nebo aby regulární výraz využil nadměrného využití procesoru, což způsobuje útok na útok DOS.|
|@NO__T – 0CA3061: Nepřidávat schéma podle adresy URL @ no__t-0|Nepoužívejte nezabezpečené přetížení metody Add, protože by mohlo dojít k nebezpečným externím odkazům.|
|[CA3075: Nezabezpečené zpracování DTD @ no__t-0|Pokud používáte nezabezpečené instance DTDProcessing nebo odkazujete na zdroje externích entit, může analyzátor přijmout nedůvěryhodné vstupní a únik citlivých informací útočníkům.|
|[CA3076: Nezabezpečený běh skriptu XSLT @ no__t-0|Pokud v aplikacích .NET nezabezpečeně vyplníte Extensible Stylesheet Language Transformers (XSLT), může procesor vyřešit nedůvěryhodné odkazy identifikátorů URI, které by mohly zveřejnit citlivé informace pro útočníky, což by způsobilo odepření služby a vzájemného pracoviště. ohrožující.|
|[CA3077: Nezabezpečené zpracování v návrhu rozhraní API, dokumentu XML a čtečce textu XML @ no__t-0|Při navrhování rozhraní API odvozeného z XMLDocument a XMLTextReader nezapomeňte na DtdProcessing. Použití nezabezpečených instancí DTDProcessing při odkazování na zdroje externích entit nebo jejich překládání na nezabezpečené hodnoty v XML může vést k odhalení informací.|
|[CA3147: Označit obslužné rutiny operací pomocí ValidateAntiForgeryToken @ no__t-0|Při navrhování kontroleru ASP.NET MVC si zajistěte útoky proti falšování požadavků mezi lokalitami. Útok proti padělání žádostí mezi servery může odesílat škodlivé požadavky od ověřeného uživatele do kontroleru ASP.NET MVC.|
|[CA5122: Deklarace volání nespravovaného kódu nesmí být kritické pro zabezpečení](../code-quality/ca5122.md)|Metody jsou při provádění operace citlivé na zabezpečení označeny jako SecuritySafeCritical, ale lze je také bezpečně použít transparentním kódem. Transparentní kód nesmí nikdy přímo volat nativní kód prostřednictvím P/Invoke. Proto označení P/Invoke jako bezpečně kritické z hlediska zabezpečení neumožní transparentnímu kódu vyvolat je a je zavádějící pro analýzu zabezpečení.|
|@NO__T – 0CA5361: Nepovolujte použití SChannel silné šifry @ no__t-0|Nastavení `Switch.System.Net.DontEnableSchUseStrongCrypto` na `true` oslabí kryptografii použitou v odchozích připojeních TLS (Transport Layer Security). Slabší kryptografie může ohrozit důvěrnost komunikace mezi vaší aplikací a serverem, což usnadňuje útočníkům eavesdrop citlivá data.|
|@NO__T – 0CA5363: Nepovolujte ověření žádosti @ no__t-0|Ověření žádosti je funkce v ASP.NET, která prověřuje požadavky HTTP a určuje, jestli obsahují potenciálně nebezpečný obsah, který může vést k útokům prostřednictvím injektáže, včetně skriptování mezi weby.|
|[CA5364: Nepoužívat zastaralé protokoly zabezpečení @ no__t-0|Protokol TLS (Transport Layer Security) zabezpečuje komunikaci mezi počítači, nejčastěji s protokolem HTTPS (Hypertext Transfer Protocol Secure). Starší verze protokolu TLS jsou méně bezpečné než TLS 1,2 a TLS 1,3 a je pravděpodobnější, že dojde k novým chybám zabezpečení. Nepoužívejte starší verze protokolu pro minimalizaci rizik.|
|@NO__T – 0CA5369: Použít XmlReader pro deserializaci @ no__t-0|Zpracování nedůvěryhodných schémat DTD a XML může povolit načítání nebezpečných externích odkazů, které by měly být omezeny pomocí objektu XmlReader s zabezpečeným překladačem nebo se zakázaným zpracováním vloženého schématu DTD a XML.|
|@NO__T – 0CA5370: Použití XmlReader k ověření čtecího zařízení @ no__t-0|Zpracování nedůvěryhodných schémat DTD a XML může povolit načítání nebezpečných externích odkazů. Toto nebezpečné načítání může být omezeno pomocí objektu XmlReader s zabezpečeným překladačem nebo zpracováním vloženého schématu DTD a XML.|
|@NO__T – 0CA5371: Použít XmlReader pro schéma Read @ no__t-0|Zpracování nedůvěryhodných schémat DTD a XML může povolit načítání nebezpečných externích odkazů. Použití objektu XmlReader s zabezpečeným překladačem nebo zpracováním vloženého schématu DTD a XML je zakázané.|
|@NO__T – 0CA5372: Použít XmlReader pro XPathDocument @ no__t-0|Zpracování XML z nedůvěryhodných dat může načítat nebezpečné externí odkazy, které mohou být omezeny pomocí objektu XmlReader s zabezpečeným překladačem nebo zakázaným zpracováním DTD.|
|@NO__T – 0CA5373: Nepoužívat zastaralou funkci odvození klíče @ no__t-0|Toto pravidlo detekuje vyvolání slabé metody odvození klíče <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> a `Rfc2898DeriveBytes.CryptDeriveKey`. <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> používá slabší PBKDF1 algoritmu.|
|@NO__T – 0CA5378: Nezakažte ServicePointManagerSecurityProtocols @ no__t-0|Nastavení `Switch.System.ServiceModel.DisableUsingServicePointManagerSecurityProtocols` na hodnotu `true` omezí připojení TLS (Transport Layer Security) Windows Communication Framework (WCF) na použití protokolu TLS 1,0. Tato verze TLS bude zastaralá.|
|@NO__T – 0CA5380: Nepřidávat certifikáty do kořenového úložiště @ no__t-0|Toto pravidlo detekuje kód, který přidá certifikát do úložiště certifikátů důvěryhodných kořenových certifikačních autorit. Ve výchozím nastavení je úložiště certifikátů důvěryhodných kořenových certifikačních autorit nakonfigurováno se sadou veřejných certifikačních autorit, které splnily požadavky programu Microsoft Root Certificate Program.|
|@NO__T – 0CA5381: Zajistěte, aby se certifikáty do kořenového úložiště nepřidaly. @ no__t-0|Toto pravidlo detekuje kód, který potenciálně přidá certifikát do úložiště certifikátů důvěryhodných kořenových certifikačních autorit. Ve výchozím nastavení je úložiště certifikátů důvěryhodných kořenových certifikačních autorit nakonfigurováno se sadou veřejných certifikačních autorit (CA), které splnily požadavky programu Microsoft Root Certificate Program.|
|[CA5386: Vyhněte se hodnotě zakódujeme SecurityProtocolType @ no__t-0|Protokol TLS (Transport Layer Security) zabezpečuje komunikaci mezi počítači, nejčastěji s protokolem HTTPS (Hypertext Transfer Protocol Secure). Verze protokolu TLS 1,0 a TLS 1,1 jsou zastaralé, zatímco protokol TLS 1,2 a TLS 1,3 jsou aktuální. V budoucnu může být TLS 1,2 a TLS 1,3 zastaralá. Aby se zajistilo, že vaše aplikace zůstane v bezpečí, vyhněte se zakódujeme verze protokolu a cílit aspoň na 4.7.1 .NET Framework v.|
|@NO__T – 0CA5389: Nepřidávat cestu položky archivu do cílové cesty k systému souborů @ no__t-0|Cesta k souboru může být relativní a může vést k přístupu k systému souborů mimo očekávanou cílovou cestu systému souborů, což vede ke škodlivým změnám konfigurace a ke vzdálenému spuštění kódu prostřednictvím techniky stanovení a čekání.|
|@NO__T – 0CA5397: Nepoužívejte zastaralé hodnoty SslProtocols určující @ no__t-0.|ransport Layer Security (TLS) zabezpečuje komunikaci mezi počítači, nejčastěji s protokolem HTTPS (Hypertext Transfer Protocol Secure). Starší verze protokolu TLS jsou méně bezpečné než TLS 1,2 a TLS 1,3 a je pravděpodobnější, že dojde k novým chybám zabezpečení. Nepoužívejte starší verze protokolu pro minimalizaci rizik.|
|@NO__T – 0CA5398: Vyhněte se hodnotám pevně zakódované SslProtocols určující @ no__t-0|Protokol TLS (Transport Layer Security) zabezpečuje komunikaci mezi počítači, nejčastěji s protokolem HTTPS (Hypertext Transfer Protocol Secure). Verze protokolu TLS 1,0 a TLS 1,1 jsou zastaralé, zatímco protokol TLS 1,2 a TLS 1,3 jsou aktuální. V budoucnu může být TLS 1,2 a TLS 1,3 zastaralá. Abyste měli jistotu, že vaše aplikace zůstane v bezpečí, vyhněte se zakódujeme verze protokolu.|
